
build/kernel.elf:     file format elf64-littleaarch64
build/kernel.elf
architecture: aarch64, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0000000040080000

Program Header:
    LOAD off    0x0000000000010000 vaddr 0x0000000040080000 paddr 0x0000000040080000 align 2**16
         filesz 0x0000000000008001 memsz 0x000000000000f018 flags rwx
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
private flags = 0x0:

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         000042a0  0000000040080000  0000000040080000  00010000  2**11
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000001ab  00000000400842a0  00000000400842a0  000142a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .eh_frame     00000714  0000000040084450  0000000040084450  00014450  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .data         00003001  0000000040085000  0000000040085000  00015000  2**12
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00006018  0000000040089000  0000000040089000  00018001  2**12
                  ALLOC
  5 .debug_line   00000e85  0000000000000000  0000000000000000  00018001  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_line_str 000001ad  0000000000000000  0000000000000000  00018e86  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_info   00001c0a  0000000000000000  0000000000000000  00019033  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_abbrev 00000c35  0000000000000000  0000000000000000  0001ac3d  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_aranges 00000270  0000000000000000  0000000000000000  0001b880  2**4
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00000654  0000000000000000  0000000000000000  0001baf0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .comment      0000001b  0000000000000000  0000000000000000  0001c144  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
0000000040080000 l    d  .text	0000000000000000 .text
00000000400842a0 l    d  .rodata	0000000000000000 .rodata
0000000040084450 l    d  .eh_frame	0000000000000000 .eh_frame
0000000040085000 l    d  .data	0000000000000000 .data
0000000040089000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_line_str	0000000000000000 .debug_line_str
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 l    df *ABS*	0000000000000000 boot.s.o
000000004008d000 l       .bss	0000000000000000 _stack_top_el3
00000000400800b4 l       .text	0000000000000000 from_el3_to_el1
0000000040080098 l       .text	0000000000000000 from_el2_to_el1
000000004008f000 l       .bss	0000000000000000 _stack_top_second
000000004008005c l       .text	0000000000000000 primary_entry
000000004008b000 l       .bss	0000000000000000 _stack_top
000000004008009c l       .text	0000000000000000 stack_test
0000000040089000 l       .bss	0000000000000000 _stack_bottom
000000004008b000 l       .bss	0000000000000000 _stack_bottom_el3
000000004008d000 l       .bss	0000000000000000 _stack_bottom_second
0000000000000000 l    df *ABS*	0000000000000000 main.c
0000000040080128 l     F .text	000000000000003c hvc_call
0000000040080164 l     F .text	000000000000001c get_current_cpu_id
0000000000000000 l    df *ABS*	0000000000000000 exception.s.o
0000000000000000 l    df *ABS*	0000000000000000 exception_el3.s.o
0000000000000000 l    df *ABS*	0000000000000000 exception.c
0000000040082058 l     F .text	0000000000000018 read_esr_el1
0000000000000000 l    df *ABS*	0000000000000000 exception_el3.c
0000000040082200 l     F .text	0000000000000018 read_esr_el3
0000000000000000 l    df *ABS*	0000000000000000 gic.c
000000004008236c l     F .text	0000000000000018 readl
0000000040082384 l     F .text	0000000000000024 writel
0000000000000000 l    df *ABS*	0000000000000000 io.c
0000000000000000 l    df *ABS*	0000000000000000 printf.c
0000000040085000 l     O .data	0000000000000010 digits
000000004008294c l     F .text	000000000000006c addchar
00000000400829b8 l     F .text	0000000000000120 print_str
0000000040082ad8 l     F .text	00000000000001a4 print_int
0000000040082c7c l     F .text	00000000000001f0 print_unsigned
0000000040082e6c l     F .text	00000000000000b4 fmtnum
0000000000000000 l    df *ABS*	0000000000000000 mmu.s.o
0000000000000000 l    df *ABS*	0000000000000000 page.c
0000000040086000 l     O .data	0000000000001000 pt0
0000000040087000 l     O .data	0000000000001000 pt1
0000000040088000 l     O .data	0000000000000001 mmu_enable_flag
0000000000000000 l    df *ABS*	0000000000000000 string.c
0000000000000000 l    df *ABS*	0000000000000000 timer.c
0000000040084210 l     F .text	0000000000000018 read_cntfrq_el0
0000000040084228 l     F .text	000000000000001c write_cntp_tval_el0
0000000040084244 l     F .text	000000000000001c write_cntp_ctl_el0
000000004008233c g     F .text	0000000000000030 invalid_exception_el3
0000000040083c7c g     F .text	000000000000002c strcpy
0000000040082724 g     F .text	00000000000000cc set_enable
00000000400837f4 g     F .text	000000000000009c printf
0000000040080800 g       .text	0000000000000000 exception_vector_base
0000000040080024 g       .text	0000000000000000 second_entry
0000000040081800 g       .text	0000000000000000 exception_vector_base_el3
0000000040083fa8 g     F .text	00000000000000d8 memmove
0000000040083700 g     F .text	000000000000008c snprintf
00000000400840ec g     F .text	0000000000000124 atol
00000000400839c8 g     F .text	00000000000000bc binstr
0000000040083ea8 g     F .text	0000000000000070 memcpy
0000000040082040 g       .text	0000000000000000 trigger_exception
00000000400828dc g     F .text	0000000000000044 uart_putstr
000000004008216c g     F .text	0000000000000064 handle_irq_exception
00000000400821d0 g     F .text	0000000000000030 invalid_exception
0000000040082f20 g     F .text	00000000000007e0 vsnprintf
0000000040080180 g     F .text	000000000000001c simple_console
000000004008259c g     F .text	0000000000000054 gicv2_ipi_send_single
00000000400823e0 g     F .text	0000000000000108 gicv2_enable_defaults
0000000040083bac g     F .text	0000000000000020 enable_mmu
00000000400801e0 g     F .text	0000000000000070 kernel_main
0000000040082568 g     F .text	0000000000000034 gicv2_write_eoir
0000000040084260 g     F .text	0000000000000038 timer_init
000000004008f000 g     O .bss	0000000000000018 _gicv2
0000000040083c0c g     F .text	0000000000000070 strcat
0000000040083a84 g     F .text	000000000000003c print_binstr
000000004008378c g     F .text	0000000000000068 vprintf
00000000400827f0 g     F .text	00000000000000b0 uart_init
0000000040084080 g     F .text	000000000000006c memchr
0000000040080000 g       .text	0000000000000000 _start
0000000040083db4 g     F .text	0000000000000094 strstr
0000000040082308 g     F .text	0000000000000034 handle_irq_exception_el3
0000000040083ca8 g     F .text	0000000000000090 strncmp
0000000040082070 g     F .text	00000000000000fc handle_sync_exception
0000000040083f18 g     F .text	0000000000000090 memcmp
00000000400823a8 g     F .text	0000000000000038 gicv2_init
0000000040082920 g     F .text	000000000000002c uart_getc
0000000040082620 g     F .text	0000000000000104 configure_interrupt
0000000040083e48 g     F .text	0000000000000060 memset
00000000400828a0 g     F .text	000000000000003c uart_putc
0000000040080250 g     F .text	0000000000000018 second_kernel_main
0000000040083d38 g     F .text	0000000000000028 strcmp
000000004008252c g     F .text	0000000000000024 gicv2_read_iar
0000000040082218 g     F .text	00000000000000f0 handle_sync_exception_el3
0000000040082550 g     F .text	0000000000000018 gicv2_iar_irqnr
000000004008392c g     F .text	000000000000009c error
0000000040083b00 g     F .text	00000000000000ac init_page_table
0000000040083ac0 g       .text	0000000000000000 init_mmu
0000000040083890 g     F .text	000000000000009c warning
000000004008019c g     F .text	0000000000000044 main_entry
00000000400824e8 g     F .text	0000000000000044 gicv2_enable_defaults_second
0000000040083bcc g     F .text	0000000000000040 strlen
0000000040083d60 g     F .text	0000000000000054 strchr
00000000400825f0 g     F .text	0000000000000030 cpu_num
0000000040084298 g     F .text	0000000000000008 handle_timer_interrupt



Disassembly of section .text:

0000000040080000 <_start>:


_start:

    // 设置栈指针
    ldr x0, =_stack_top_el3
    40080000:	58000840 	ldr	x0, 40080108 <from_el3_to_el1+0x54>
    mov sp, x0
    40080004:	9100001f 	mov	sp, x0

    mrs x0, CurrentEL          // Read current exception level
    40080008:	d5384240 	mrs	x0, currentel
    lsr x0, x0, #2             // 右移两位
    4008000c:	d342fc00 	lsr	x0, x0, #2
    
    cmp x0, #3
    40080010:	f1000c1f 	cmp	x0, #0x3
    b.eq from_el3_to_el1       // Branch if we are in EL3
    40080014:	54000500 	b.eq	400800b4 <from_el3_to_el1>  // b.none

    cmp x0, #2
    40080018:	f100081f 	cmp	x0, #0x2
    b.eq from_el2_to_el1       // Branch if we are in EL2
    4008001c:	540003e0 	b.eq	40080098 <from_el2_to_el1>  // b.none

    b   .
    40080020:	14000000 	b	40080020 <_start+0x20>

0000000040080024 <second_entry>:
*/

// 此时CPU已经工作在EL1状态
second_entry:
    // 查看当前异常等级
    mrs x0, CurrentEL          // Read current exception level
    40080024:	d5384240 	mrs	x0, currentel
    lsr x0, x0, #2             // 右移两位
    40080028:	d342fc00 	lsr	x0, x0, #2
    
    // 设置栈指针
    ldr x0, =_stack_top_second
    4008002c:	58000720 	ldr	x0, 40080110 <from_el3_to_el1+0x5c>
    mov sp, x0
    40080030:	9100001f 	mov	sp, x0

    // 使用 cpu0 的页表
    bl      enable_mmu
    40080034:	94000ede 	bl	40083bac <enable_mmu>

    // 设置栈指针
    ldr x0, =_stack_top_second
    40080038:	580006c0 	ldr	x0, 40080110 <from_el3_to_el1+0x5c>
    mov sp, x0
    4008003c:	9100001f 	mov	sp, x0

    adrp    x0, exception_vector_base
    40080040:	90000000 	adrp	x0, 40080000 <_start>
    add     x0, x0, :lo12:exception_vector_base
    40080044:	91200000 	add	x0, x0, #0x800
    msr     vbar_el1, x0
    40080048:	d518c000 	msr	vbar_el1, x0
    dsb     sy      // 确保所有内存访问完成
    4008004c:	d5033f9f 	dsb	sy
    isb             // 确保所有指令都执行完成
    40080050:	d5033fdf 	isb

    bl second_kernel_main
    40080054:	9400007f 	bl	40080250 <second_kernel_main>

    b .
    40080058:	14000000 	b	40080058 <second_entry+0x34>

000000004008005c <primary_entry>:

// 此时CPU已经工作在EL1状态
primary_entry:
    // 查看当前异常等级
    mrs x0, CurrentEL          // Read current exception level
    4008005c:	d5384240 	mrs	x0, currentel
    lsr x0, x0, #2             // 右移两位
    40080060:	d342fc00 	lsr	x0, x0, #2

    // 设置栈指针
    ldr x0, =_stack_top
    40080064:	580005a0 	ldr	x0, 40080118 <from_el3_to_el1+0x64>
    mov sp, x0
    40080068:	9100001f 	mov	sp, x0

    bl init_page_table
    4008006c:	94000ea5 	bl	40083b00 <init_page_table>
    bl enable_mmu
    40080070:	94000ecf 	bl	40083bac <enable_mmu>

    // 设置栈指针
    ldr x0, =_stack_top
    40080074:	58000520 	ldr	x0, 40080118 <from_el3_to_el1+0x64>
    mov sp, x0
    40080078:	9100001f 	mov	sp, x0

    adrp    x0, exception_vector_base
    4008007c:	90000000 	adrp	x0, 40080000 <_start>
    add     x0, x0, :lo12:exception_vector_base
    40080080:	91200000 	add	x0, x0, #0x800
    msr     vbar_el1, x0
    40080084:	d518c000 	msr	vbar_el1, x0
    dsb     sy      // 确保所有内存访问完成
    40080088:	d5033f9f 	dsb	sy
    isb             // 确保所有指令都执行完成
    4008008c:	d5033fdf 	isb

    // 调用 C 语言的 main 函数
    bl kernel_main
    40080090:	94000054 	bl	400801e0 <kernel_main>

	b .
    40080094:	14000000 	b	40080094 <primary_entry+0x38>

0000000040080098 <from_el2_to_el1>:



// 从el2到el1
from_el2_to_el1:
    b .
    40080098:	14000000 	b	40080098 <from_el2_to_el1>

000000004008009c <stack_test>:

stack_test:
    mov x0, #1
    4008009c:	d2800020 	mov	x0, #0x1                   	// #1
    mov x1, #2
    400800a0:	d2800041 	mov	x1, #0x2                   	// #2
    sub sp, sp, 2 * 8
    400800a4:	d10043ff 	sub	sp, sp, #0x10
    str	x0, [sp, #0]
    400800a8:	f90003e0 	str	x0, [sp]
    str	x1, [sp, #8]
    400800ac:	f90007e1 	str	x1, [sp, #8]
    add sp, sp, 2 * 8
    400800b0:	910043ff 	add	sp, sp, #0x10

00000000400800b4 <from_el3_to_el1>:

from_el3_to_el1:
    // 设置 SCR_EL3 寄存器
    mrs x0, scr_el3
    400800b4:	d53e1100 	mrs	x0, scr_el3
    orr x0, x0, #(1 << 0)     // 设置 NS 位为 1，进入非安全世界
    400800b8:	b2400000 	orr	x0, x0, #0x1
    orr x0, x0, #(1 << 10)    // 设置 HCE 位为 1，允许 HVC 指令
    400800bc:	b2760000 	orr	x0, x0, #0x400
    bic x0, x0, #(1 << 7)     // 清除 SMD 位，使能 SMC 指令
    400800c0:	9278f800 	and	x0, x0, #0xffffffffffffff7f
    msr scr_el3, x0
    400800c4:	d51e1100 	msr	scr_el3, x0

    // 设置 HCD 位为 1，允许 HVC 指令
    mrs x0, hcr_el2           // 读取 HCR_EL2 寄存器
    400800c8:	d53c1100 	mrs	x0, hcr_el2
    orr x0, x0, #(1 << 29)    // 设置 HCD 位 (位29) 为 1
    400800cc:	b2630000 	orr	x0, x0, #0x20000000
    msr hcr_el2, x0           // 写回 HCR_EL2 寄存器
    400800d0:	d51c1100 	msr	hcr_el2, x0

    adrp    x0, exception_vector_base_el3
    400800d4:	b0000000 	adrp	x0, 40081000 <exception_vector_base+0x800>
    add     x0, x0, :lo12:exception_vector_base_el3
    400800d8:	91200000 	add	x0, x0, #0x800
    msr     vbar_el3, x0
    400800dc:	d51ec000 	msr	vbar_el3, x0
    dsb     sy      // 确保所有内存访问完成
    400800e0:	d5033f9f 	dsb	sy
    isb             // 确保所有指令都执行完成
    400800e4:	d5033fdf 	isb


    // 设置 SPSR_EL3 寄存器
    // 将目标处理器状态设置为 EL1h 模式
    mov x0,     #(0b0101 << 0)   // 设置 M[4:0] 为 0b0101，即 EL1h 模式
    400800e8:	d28000a0 	mov	x0, #0x5                   	// #5
    orr x0, x0, #(0b1111 << 6)   // 设置 DAIF[3:0] 为 0b1111，禁用所有中断
    400800ec:	b27a0c00 	orr	x0, x0, #0x3c0
    msr spsr_el3, x0
    400800f0:	d51e4000 	msr	spsr_el3, x0

    // 设置 ELR_EL3 寄存器
    // 设置返回地址为 EL1 的入口点
    ldr x0, =primary_entry
    400800f4:	58000160 	ldr	x0, 40080120 <from_el3_to_el1+0x6c>
    msr elr_el3, x0
    400800f8:	d51e4020 	msr	elr_el3, x0

    // 设置 SP_EL1 寄存器
    // 设置 EL1 的堆栈指针
    ldr x0, =_stack_top
    400800fc:	580000e0 	ldr	x0, 40080118 <from_el3_to_el1+0x64>
    msr sp_el1, x0
    40080100:	d51c4100 	msr	sp_el1, x0

    // 使用 ERET 指令返回到 EL1
    eret
    40080104:	d69f03e0 	eret
    40080108:	4008d000 	.word	0x4008d000
    4008010c:	00000000 	.word	0x00000000
    40080110:	4008f000 	.word	0x4008f000
    40080114:	00000000 	.word	0x00000000
    40080118:	4008b000 	.word	0x4008b000
    4008011c:	00000000 	.word	0x00000000
    40080120:	4008005c 	.word	0x4008005c
    40080124:	00000000 	.word	0x00000000

0000000040080128 <hvc_call>:
 
    ret = (int)reg0;
    return ret;
}

static inline uint32_t hvc_call(uint32_t function_id, uint64_t arg0, uint64_t arg1, uint64_t arg2) {
    40080128:	d100c3ff 	sub	sp, sp, #0x30
    4008012c:	f9000fe0 	str	x0, [sp, #24]
    40080130:	f9000be1 	str	x1, [sp, #16]
    40080134:	f90007e2 	str	x2, [sp, #8]
    40080138:	f90003e3 	str	x3, [sp]
    register uint64_t reg0 __asm__("x0") = function_id;
    4008013c:	f9400fe0 	ldr	x0, [sp, #24]
    register uint64_t reg1 __asm__("x1") = arg0;
    40080140:	f9400be1 	ldr	x1, [sp, #16]
    register uint64_t reg2 __asm__("x2") = arg1;
    40080144:	f94007e2 	ldr	x2, [sp, #8]
    register uint64_t reg3 __asm__("x3") = arg2;
    40080148:	f94003e3 	ldr	x3, [sp]
    int ret = 0;
    4008014c:	b9002fff 	str	wzr, [sp, #44]
 
    asm volatile ("hvc    #0\n" : "+r" (reg0) :"r"(reg1), "r"(reg2), "r"(reg3));
    40080150:	d4000002 	hvc	#0x0
 
    ret = (int)reg0;
    40080154:	b9002fe0 	str	w0, [sp, #44]
    return ret;
    40080158:	b9802fe0 	ldrsw	x0, [sp, #44]
}
    4008015c:	9100c3ff 	add	sp, sp, #0x30
    40080160:	d65f03c0 	ret

0000000040080164 <get_current_cpu_id>:
#include "smp.h"
#include "psci.h"
#include "gic.h"
#include "timer.h"

static inline unsigned int get_current_cpu_id(void) {
    40080164:	d10043ff 	sub	sp, sp, #0x10
    unsigned long mpidr;
    asm volatile ("mrs %0, mpidr_el1" : "=r" (mpidr));
    40080168:	d53800a0 	mrs	x0, mpidr_el1
    4008016c:	f90007e0 	str	x0, [sp, #8]
    return (unsigned int)(mpidr & 0xff);
    40080170:	f94007e0 	ldr	x0, [sp, #8]
    40080174:	12001c00 	and	w0, w0, #0xff
}
    40080178:	910043ff 	add	sp, sp, #0x10
    4008017c:	d65f03c0 	ret

0000000040080180 <simple_console>:

extern void second_entry();

void simple_console() {
    40080180:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40080184:	910003fd 	mov	x29, sp
    while(1) 
    {
        char c = uart_getc();
    40080188:	940009e6 	bl	40082920 <uart_getc>
    4008018c:	39007fe0 	strb	w0, [sp, #31]
        uart_putc(c);
    40080190:	39407fe0 	ldrb	w0, [sp, #31]
    40080194:	940009c3 	bl	400828a0 <uart_putc>
    {
    40080198:	17fffffc 	b	40080188 <simple_console+0x8>

000000004008019c <main_entry>:
    }
}

void main_entry() {
    4008019c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400801a0:	910003fd 	mov	x29, sp
    while(1) {
        for(uint64_t i=0; i<0xffffff; i++);
    400801a4:	f9000fff 	str	xzr, [sp, #24]
    400801a8:	14000004 	b	400801b8 <main_entry+0x1c>
    400801ac:	f9400fe0 	ldr	x0, [sp, #24]
    400801b0:	91000400 	add	x0, x0, #0x1
    400801b4:	f9000fe0 	str	x0, [sp, #24]
    400801b8:	f9400fe1 	ldr	x1, [sp, #24]
    400801bc:	b27f5be0 	mov	x0, #0xfffffe              	// #16777214
    400801c0:	eb00003f 	cmp	x1, x0
    400801c4:	54ffff49 	b.ls	400801ac <main_entry+0x10>  // b.plast
        printf("get_current_cpu_id: %d\n", get_current_cpu_id());
    400801c8:	97ffffe7 	bl	40080164 <get_current_cpu_id>
    400801cc:	2a0003e1 	mov	w1, w0
    400801d0:	90000020 	adrp	x0, 40084000 <memmove+0x58>
    400801d4:	910a8000 	add	x0, x0, #0x2a0
    400801d8:	94000d87 	bl	400837f4 <printf>
        for(uint64_t i=0; i<0xffffff; i++);
    400801dc:	17fffff2 	b	400801a4 <main_entry+0x8>

00000000400801e0 <kernel_main>:
    }
}

void kernel_main(void) {
    400801e0:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400801e4:	910003fd 	mov	x29, sp

	uart_init();
    400801e8:	94000982 	bl	400827f0 <uart_init>

    gicv2_init();
    400801ec:	9400086f 	bl	400823a8 <gicv2_init>

    timer_init();
    400801f0:	9400101c 	bl	40084260 <timer_init>

    uart_putstr("start core\n");
    400801f4:	90000020 	adrp	x0, 40084000 <memmove+0x58>
    400801f8:	910ae000 	add	x0, x0, #0x2b8
    400801fc:	940009b8 	bl	400828dc <uart_putstr>

    int result = hvc_call(PSCI_0_2_FN64_CPU_ON, 1, (uint64_t)(void*)second_entry, 0x40086000);
    40080200:	90000000 	adrp	x0, 40080000 <_start>
    40080204:	91009000 	add	x0, x0, #0x24
    40080208:	d28c0003 	mov	x3, #0x6000                	// #24576
    4008020c:	f2a80103 	movk	x3, #0x4008, lsl #16
    40080210:	aa0003e2 	mov	x2, x0
    40080214:	d2800021 	mov	x1, #0x1                   	// #1
    40080218:	d2800060 	mov	x0, #0x3                   	// #3
    4008021c:	f2b88000 	movk	x0, #0xc400, lsl #16
    40080220:	97ffffc2 	bl	40080128 <hvc_call>
    40080224:	b9001fe0 	str	w0, [sp, #28]
    if (result != 0) {
    40080228:	b9401fe0 	ldr	w0, [sp, #28]
    4008022c:	7100001f 	cmp	w0, #0x0
    40080230:	54000080 	b.eq	40080240 <kernel_main+0x60>  // b.none
        printf("start core 1 failed!\n");
    40080234:	90000020 	adrp	x0, 40084000 <memmove+0x58>
    40080238:	910b2000 	add	x0, x0, #0x2c8
    4008023c:	94000d6e 	bl	400837f4 <printf>
    }

    main_entry();
    40080240:	97ffffd7 	bl	4008019c <main_entry>
    // can't reach here !
}
    40080244:	d503201f 	nop
    40080248:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4008024c:	d65f03c0 	ret

0000000040080250 <second_kernel_main>:

void second_kernel_main() {
    40080250:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40080254:	910003fd 	mov	x29, sp

    main_entry();
    40080258:	97ffffd1 	bl	4008019c <main_entry>
    // can't reach here !
    4008025c:	d503201f 	nop
    40080260:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40080264:	d65f03c0 	ret
	...

0000000040080800 <exception_vector_base>:
.extern handle_sync_exception
.extern handle_irq_exception

exception_vector_base:
    // current EL, with SP_EL0
    INVALID_EXCP 0 0
    40080800:	d10443ff 	sub	sp, sp, #0x110
    40080804:	a90007e0 	stp	x0, x1, [sp]
    40080808:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008080c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080810:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080814:	a90427e8 	stp	x8, x9, [sp, #64]
    40080818:	a9052fea 	stp	x10, x11, [sp, #80]
    4008081c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080820:	a9073fee 	stp	x14, x15, [sp, #112]
    40080824:	a90847f0 	stp	x16, x17, [sp, #128]
    40080828:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008082c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080830:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080834:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080838:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008083c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080840:	d5384109 	mrs	x9, sp_el0
    40080844:	d538402a 	mrs	x10, elr_el1
    40080848:	d538400b 	mrs	x11, spsr_el1
    4008084c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080850:	a9102fea 	stp	x10, x11, [sp, #256]
    40080854:	910003e0 	mov	x0, sp
    40080858:	d2800001 	mov	x1, #0x0                   	// #0
    4008085c:	d2800002 	mov	x2, #0x0                   	// #0
    40080860:	9400065c 	bl	400821d0 <invalid_exception>
    40080864:	140001e1 	b	40080fe8 <exception_vector_base+0x7e8>
    40080868:	d503201f 	nop
    4008086c:	d503201f 	nop
    40080870:	d503201f 	nop
    40080874:	d503201f 	nop
    40080878:	d503201f 	nop
    4008087c:	d503201f 	nop
    INVALID_EXCP 1 0
    40080880:	d10443ff 	sub	sp, sp, #0x110
    40080884:	a90007e0 	stp	x0, x1, [sp]
    40080888:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008088c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080890:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080894:	a90427e8 	stp	x8, x9, [sp, #64]
    40080898:	a9052fea 	stp	x10, x11, [sp, #80]
    4008089c:	a90637ec 	stp	x12, x13, [sp, #96]
    400808a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400808a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400808a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400808ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400808b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400808b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400808b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400808bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400808c0:	d5384109 	mrs	x9, sp_el0
    400808c4:	d538402a 	mrs	x10, elr_el1
    400808c8:	d538400b 	mrs	x11, spsr_el1
    400808cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400808d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400808d4:	910003e0 	mov	x0, sp
    400808d8:	d2800021 	mov	x1, #0x1                   	// #1
    400808dc:	d2800002 	mov	x2, #0x0                   	// #0
    400808e0:	9400063c 	bl	400821d0 <invalid_exception>
    400808e4:	140001c1 	b	40080fe8 <exception_vector_base+0x7e8>
    400808e8:	d503201f 	nop
    400808ec:	d503201f 	nop
    400808f0:	d503201f 	nop
    400808f4:	d503201f 	nop
    400808f8:	d503201f 	nop
    400808fc:	d503201f 	nop
    INVALID_EXCP 2 0
    40080900:	d10443ff 	sub	sp, sp, #0x110
    40080904:	a90007e0 	stp	x0, x1, [sp]
    40080908:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008090c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080910:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080914:	a90427e8 	stp	x8, x9, [sp, #64]
    40080918:	a9052fea 	stp	x10, x11, [sp, #80]
    4008091c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080920:	a9073fee 	stp	x14, x15, [sp, #112]
    40080924:	a90847f0 	stp	x16, x17, [sp, #128]
    40080928:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008092c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080930:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080934:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080938:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008093c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080940:	d5384109 	mrs	x9, sp_el0
    40080944:	d538402a 	mrs	x10, elr_el1
    40080948:	d538400b 	mrs	x11, spsr_el1
    4008094c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080950:	a9102fea 	stp	x10, x11, [sp, #256]
    40080954:	910003e0 	mov	x0, sp
    40080958:	d2800041 	mov	x1, #0x2                   	// #2
    4008095c:	d2800002 	mov	x2, #0x0                   	// #0
    40080960:	9400061c 	bl	400821d0 <invalid_exception>
    40080964:	140001a1 	b	40080fe8 <exception_vector_base+0x7e8>
    40080968:	d503201f 	nop
    4008096c:	d503201f 	nop
    40080970:	d503201f 	nop
    40080974:	d503201f 	nop
    40080978:	d503201f 	nop
    4008097c:	d503201f 	nop
    INVALID_EXCP 3 0
    40080980:	d10443ff 	sub	sp, sp, #0x110
    40080984:	a90007e0 	stp	x0, x1, [sp]
    40080988:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008098c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080990:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080994:	a90427e8 	stp	x8, x9, [sp, #64]
    40080998:	a9052fea 	stp	x10, x11, [sp, #80]
    4008099c:	a90637ec 	stp	x12, x13, [sp, #96]
    400809a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400809a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400809a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400809ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400809b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400809b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400809b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400809bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400809c0:	d5384109 	mrs	x9, sp_el0
    400809c4:	d538402a 	mrs	x10, elr_el1
    400809c8:	d538400b 	mrs	x11, spsr_el1
    400809cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400809d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400809d4:	910003e0 	mov	x0, sp
    400809d8:	d2800061 	mov	x1, #0x3                   	// #3
    400809dc:	d2800002 	mov	x2, #0x0                   	// #0
    400809e0:	940005fc 	bl	400821d0 <invalid_exception>
    400809e4:	14000181 	b	40080fe8 <exception_vector_base+0x7e8>
    400809e8:	d503201f 	nop
    400809ec:	d503201f 	nop
    400809f0:	d503201f 	nop
    400809f4:	d503201f 	nop
    400809f8:	d503201f 	nop
    400809fc:	d503201f 	nop

    // current EL, with SP_ELx
    HANDLE_SYNC
    40080a00:	d10443ff 	sub	sp, sp, #0x110
    40080a04:	a90007e0 	stp	x0, x1, [sp]
    40080a08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080a0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080a10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080a14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080a18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080a1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080a20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080a24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080a28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080a2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080a30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080a34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080a38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080a3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080a40:	d5384109 	mrs	x9, sp_el0
    40080a44:	d538402a 	mrs	x10, elr_el1
    40080a48:	d538400b 	mrs	x11, spsr_el1
    40080a4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080a50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080a54:	910003e0 	mov	x0, sp
    40080a58:	94000586 	bl	40082070 <handle_sync_exception>
    40080a5c:	14000163 	b	40080fe8 <exception_vector_base+0x7e8>
    40080a60:	d503201f 	nop
    40080a64:	d503201f 	nop
    40080a68:	d503201f 	nop
    40080a6c:	d503201f 	nop
    40080a70:	d503201f 	nop
    40080a74:	d503201f 	nop
    40080a78:	d503201f 	nop
    40080a7c:	d503201f 	nop
    HANDLE_IRQ
    40080a80:	d10443ff 	sub	sp, sp, #0x110
    40080a84:	a90007e0 	stp	x0, x1, [sp]
    40080a88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080a8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080a90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080a94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080a98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080a9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080aa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080aa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080aa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080aac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080ab0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080ab4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080ab8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080abc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080ac0:	d5384109 	mrs	x9, sp_el0
    40080ac4:	d538402a 	mrs	x10, elr_el1
    40080ac8:	d538400b 	mrs	x11, spsr_el1
    40080acc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080ad0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080ad4:	910003e0 	mov	x0, sp
    40080ad8:	940005a5 	bl	4008216c <handle_irq_exception>
    40080adc:	14000143 	b	40080fe8 <exception_vector_base+0x7e8>
    40080ae0:	d503201f 	nop
    40080ae4:	d503201f 	nop
    40080ae8:	d503201f 	nop
    40080aec:	d503201f 	nop
    40080af0:	d503201f 	nop
    40080af4:	d503201f 	nop
    40080af8:	d503201f 	nop
    40080afc:	d503201f 	nop
    INVALID_EXCP 2 1
    40080b00:	d10443ff 	sub	sp, sp, #0x110
    40080b04:	a90007e0 	stp	x0, x1, [sp]
    40080b08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080b0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080b10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080b14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080b18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080b1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080b20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080b24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080b28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080b2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080b30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080b34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080b38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080b3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080b40:	d5384109 	mrs	x9, sp_el0
    40080b44:	d538402a 	mrs	x10, elr_el1
    40080b48:	d538400b 	mrs	x11, spsr_el1
    40080b4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080b50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080b54:	910003e0 	mov	x0, sp
    40080b58:	d2800041 	mov	x1, #0x2                   	// #2
    40080b5c:	d2800022 	mov	x2, #0x1                   	// #1
    40080b60:	9400059c 	bl	400821d0 <invalid_exception>
    40080b64:	14000121 	b	40080fe8 <exception_vector_base+0x7e8>
    40080b68:	d503201f 	nop
    40080b6c:	d503201f 	nop
    40080b70:	d503201f 	nop
    40080b74:	d503201f 	nop
    40080b78:	d503201f 	nop
    40080b7c:	d503201f 	nop
    INVALID_EXCP 3 1
    40080b80:	d10443ff 	sub	sp, sp, #0x110
    40080b84:	a90007e0 	stp	x0, x1, [sp]
    40080b88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080b8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080b90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080b94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080b98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080b9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080ba0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080ba4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080ba8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080bac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080bb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080bb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080bb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080bbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080bc0:	d5384109 	mrs	x9, sp_el0
    40080bc4:	d538402a 	mrs	x10, elr_el1
    40080bc8:	d538400b 	mrs	x11, spsr_el1
    40080bcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080bd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080bd4:	910003e0 	mov	x0, sp
    40080bd8:	d2800061 	mov	x1, #0x3                   	// #3
    40080bdc:	d2800022 	mov	x2, #0x1                   	// #1
    40080be0:	9400057c 	bl	400821d0 <invalid_exception>
    40080be4:	14000101 	b	40080fe8 <exception_vector_base+0x7e8>
    40080be8:	d503201f 	nop
    40080bec:	d503201f 	nop
    40080bf0:	d503201f 	nop
    40080bf4:	d503201f 	nop
    40080bf8:	d503201f 	nop
    40080bfc:	d503201f 	nop

    // lower EL, aarch64
    HANDLE_SYNC
    40080c00:	d10443ff 	sub	sp, sp, #0x110
    40080c04:	a90007e0 	stp	x0, x1, [sp]
    40080c08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080c0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080c10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080c14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080c18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080c1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080c20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080c24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080c28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080c2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080c30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080c34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080c38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080c3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080c40:	d5384109 	mrs	x9, sp_el0
    40080c44:	d538402a 	mrs	x10, elr_el1
    40080c48:	d538400b 	mrs	x11, spsr_el1
    40080c4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080c50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080c54:	910003e0 	mov	x0, sp
    40080c58:	94000506 	bl	40082070 <handle_sync_exception>
    40080c5c:	140000e3 	b	40080fe8 <exception_vector_base+0x7e8>
    40080c60:	d503201f 	nop
    40080c64:	d503201f 	nop
    40080c68:	d503201f 	nop
    40080c6c:	d503201f 	nop
    40080c70:	d503201f 	nop
    40080c74:	d503201f 	nop
    40080c78:	d503201f 	nop
    40080c7c:	d503201f 	nop
    HANDLE_IRQ
    40080c80:	d10443ff 	sub	sp, sp, #0x110
    40080c84:	a90007e0 	stp	x0, x1, [sp]
    40080c88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080c8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080c90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080c94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080c98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080c9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080ca0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080ca4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080ca8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080cac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080cb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080cb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080cb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080cbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080cc0:	d5384109 	mrs	x9, sp_el0
    40080cc4:	d538402a 	mrs	x10, elr_el1
    40080cc8:	d538400b 	mrs	x11, spsr_el1
    40080ccc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080cd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080cd4:	910003e0 	mov	x0, sp
    40080cd8:	94000525 	bl	4008216c <handle_irq_exception>
    40080cdc:	140000c3 	b	40080fe8 <exception_vector_base+0x7e8>
    40080ce0:	d503201f 	nop
    40080ce4:	d503201f 	nop
    40080ce8:	d503201f 	nop
    40080cec:	d503201f 	nop
    40080cf0:	d503201f 	nop
    40080cf4:	d503201f 	nop
    40080cf8:	d503201f 	nop
    40080cfc:	d503201f 	nop
    INVALID_EXCP 2 2
    40080d00:	d10443ff 	sub	sp, sp, #0x110
    40080d04:	a90007e0 	stp	x0, x1, [sp]
    40080d08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080d0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080d10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080d14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080d18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080d1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080d20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080d24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080d28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080d2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080d30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080d34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080d38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080d3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080d40:	d5384109 	mrs	x9, sp_el0
    40080d44:	d538402a 	mrs	x10, elr_el1
    40080d48:	d538400b 	mrs	x11, spsr_el1
    40080d4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080d50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080d54:	910003e0 	mov	x0, sp
    40080d58:	d2800041 	mov	x1, #0x2                   	// #2
    40080d5c:	d2800042 	mov	x2, #0x2                   	// #2
    40080d60:	9400051c 	bl	400821d0 <invalid_exception>
    40080d64:	140000a1 	b	40080fe8 <exception_vector_base+0x7e8>
    40080d68:	d503201f 	nop
    40080d6c:	d503201f 	nop
    40080d70:	d503201f 	nop
    40080d74:	d503201f 	nop
    40080d78:	d503201f 	nop
    40080d7c:	d503201f 	nop
    INVALID_EXCP 3 2
    40080d80:	d10443ff 	sub	sp, sp, #0x110
    40080d84:	a90007e0 	stp	x0, x1, [sp]
    40080d88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080d8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080d90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080d94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080d98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080d9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080da0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080da4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080da8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080dac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080db0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080db4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080db8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080dbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080dc0:	d5384109 	mrs	x9, sp_el0
    40080dc4:	d538402a 	mrs	x10, elr_el1
    40080dc8:	d538400b 	mrs	x11, spsr_el1
    40080dcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080dd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080dd4:	910003e0 	mov	x0, sp
    40080dd8:	d2800061 	mov	x1, #0x3                   	// #3
    40080ddc:	d2800042 	mov	x2, #0x2                   	// #2
    40080de0:	940004fc 	bl	400821d0 <invalid_exception>
    40080de4:	14000081 	b	40080fe8 <exception_vector_base+0x7e8>
    40080de8:	d503201f 	nop
    40080dec:	d503201f 	nop
    40080df0:	d503201f 	nop
    40080df4:	d503201f 	nop
    40080df8:	d503201f 	nop
    40080dfc:	d503201f 	nop

    // lower EL, aarch32
    INVALID_EXCP 0 3
    40080e00:	d10443ff 	sub	sp, sp, #0x110
    40080e04:	a90007e0 	stp	x0, x1, [sp]
    40080e08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080e0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080e10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080e14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080e18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080e1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080e20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080e24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080e28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080e2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080e30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080e34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080e38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080e3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080e40:	d5384109 	mrs	x9, sp_el0
    40080e44:	d538402a 	mrs	x10, elr_el1
    40080e48:	d538400b 	mrs	x11, spsr_el1
    40080e4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080e50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080e54:	910003e0 	mov	x0, sp
    40080e58:	d2800001 	mov	x1, #0x0                   	// #0
    40080e5c:	d2800062 	mov	x2, #0x3                   	// #3
    40080e60:	940004dc 	bl	400821d0 <invalid_exception>
    40080e64:	14000061 	b	40080fe8 <exception_vector_base+0x7e8>
    40080e68:	d503201f 	nop
    40080e6c:	d503201f 	nop
    40080e70:	d503201f 	nop
    40080e74:	d503201f 	nop
    40080e78:	d503201f 	nop
    40080e7c:	d503201f 	nop
    INVALID_EXCP 1 3
    40080e80:	d10443ff 	sub	sp, sp, #0x110
    40080e84:	a90007e0 	stp	x0, x1, [sp]
    40080e88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080e8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080e90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080e94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080e98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080e9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080ea0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080ea4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080ea8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080eac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080eb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080eb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080eb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080ebc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080ec0:	d5384109 	mrs	x9, sp_el0
    40080ec4:	d538402a 	mrs	x10, elr_el1
    40080ec8:	d538400b 	mrs	x11, spsr_el1
    40080ecc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080ed0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080ed4:	910003e0 	mov	x0, sp
    40080ed8:	d2800021 	mov	x1, #0x1                   	// #1
    40080edc:	d2800062 	mov	x2, #0x3                   	// #3
    40080ee0:	940004bc 	bl	400821d0 <invalid_exception>
    40080ee4:	14000041 	b	40080fe8 <exception_vector_base+0x7e8>
    40080ee8:	d503201f 	nop
    40080eec:	d503201f 	nop
    40080ef0:	d503201f 	nop
    40080ef4:	d503201f 	nop
    40080ef8:	d503201f 	nop
    40080efc:	d503201f 	nop
    INVALID_EXCP 2 3
    40080f00:	d10443ff 	sub	sp, sp, #0x110
    40080f04:	a90007e0 	stp	x0, x1, [sp]
    40080f08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080f0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080f10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080f14:	a90427e8 	stp	x8, x9, [sp, #64]
    40080f18:	a9052fea 	stp	x10, x11, [sp, #80]
    40080f1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080f20:	a9073fee 	stp	x14, x15, [sp, #112]
    40080f24:	a90847f0 	stp	x16, x17, [sp, #128]
    40080f28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080f2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080f30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080f34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080f38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080f3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080f40:	d5384109 	mrs	x9, sp_el0
    40080f44:	d538402a 	mrs	x10, elr_el1
    40080f48:	d538400b 	mrs	x11, spsr_el1
    40080f4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080f50:	a9102fea 	stp	x10, x11, [sp, #256]
    40080f54:	910003e0 	mov	x0, sp
    40080f58:	d2800041 	mov	x1, #0x2                   	// #2
    40080f5c:	d2800062 	mov	x2, #0x3                   	// #3
    40080f60:	9400049c 	bl	400821d0 <invalid_exception>
    40080f64:	14000021 	b	40080fe8 <exception_vector_base+0x7e8>
    40080f68:	d503201f 	nop
    40080f6c:	d503201f 	nop
    40080f70:	d503201f 	nop
    40080f74:	d503201f 	nop
    40080f78:	d503201f 	nop
    40080f7c:	d503201f 	nop
    INVALID_EXCP 3 3
    40080f80:	d10443ff 	sub	sp, sp, #0x110
    40080f84:	a90007e0 	stp	x0, x1, [sp]
    40080f88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40080f8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40080f90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40080f94:	a90427e8 	stp	x8, x9, [sp, #64]
    40080f98:	a9052fea 	stp	x10, x11, [sp, #80]
    40080f9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40080fa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40080fa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40080fa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40080fac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40080fb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40080fb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40080fb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40080fbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40080fc0:	d5384109 	mrs	x9, sp_el0
    40080fc4:	d538402a 	mrs	x10, elr_el1
    40080fc8:	d538400b 	mrs	x11, spsr_el1
    40080fcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40080fd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40080fd4:	910003e0 	mov	x0, sp
    40080fd8:	d2800061 	mov	x1, #0x3                   	// #3
    40080fdc:	d2800062 	mov	x2, #0x3                   	// #3
    40080fe0:	9400047c 	bl	400821d0 <invalid_exception>
    40080fe4:	14000001 	b	40080fe8 <exception_vector_base+0x7e8>

.Lexception_return:
    RESTORE_REGS
    40080fe8:	a9502fea 	ldp	x10, x11, [sp, #256]
    40080fec:	a94f27fe 	ldp	x30, x9, [sp, #240]
    40080ff0:	d5184109 	msr	sp_el0, x9
    40080ff4:	d518402a 	msr	elr_el1, x10
    40080ff8:	d518400b 	msr	spsr_el1, x11
    40080ffc:	a94e77fc 	ldp	x28, x29, [sp, #224]
    40081000:	a94d6ffa 	ldp	x26, x27, [sp, #208]
    40081004:	a94c67f8 	ldp	x24, x25, [sp, #192]
    40081008:	a94b5ff6 	ldp	x22, x23, [sp, #176]
    4008100c:	a94a57f4 	ldp	x20, x21, [sp, #160]
    40081010:	a9494ff2 	ldp	x18, x19, [sp, #144]
    40081014:	a94847f0 	ldp	x16, x17, [sp, #128]
    40081018:	a9473fee 	ldp	x14, x15, [sp, #112]
    4008101c:	a94637ec 	ldp	x12, x13, [sp, #96]
    40081020:	a9452fea 	ldp	x10, x11, [sp, #80]
    40081024:	a94427e8 	ldp	x8, x9, [sp, #64]
    40081028:	a9431fe6 	ldp	x6, x7, [sp, #48]
    4008102c:	a94217e4 	ldp	x4, x5, [sp, #32]
    40081030:	a9410fe2 	ldp	x2, x3, [sp, #16]
    40081034:	a94007e0 	ldp	x0, x1, [sp]
    40081038:	910443ff 	add	sp, sp, #0x110
    eret
    4008103c:	d69f03e0 	eret
	...

0000000040081800 <exception_vector_base_el3>:
.extern handle_sync_exception_el3
.extern handle_irq_exception_el3

exception_vector_base_el3:
    // current EL, with SP_EL0
    INVALID_EXCP 0 0
    40081800:	d10443ff 	sub	sp, sp, #0x110
    40081804:	a90007e0 	stp	x0, x1, [sp]
    40081808:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008180c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081810:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081814:	a90427e8 	stp	x8, x9, [sp, #64]
    40081818:	a9052fea 	stp	x10, x11, [sp, #80]
    4008181c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081820:	a9073fee 	stp	x14, x15, [sp, #112]
    40081824:	a90847f0 	stp	x16, x17, [sp, #128]
    40081828:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008182c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081830:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081834:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081838:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008183c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081840:	d53c4109 	mrs	x9, sp_el1
    40081844:	d53e402a 	mrs	x10, elr_el3
    40081848:	d53e400b 	mrs	x11, spsr_el3
    4008184c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081850:	a9102fea 	stp	x10, x11, [sp, #256]
    40081854:	910003e0 	mov	x0, sp
    40081858:	d2800001 	mov	x1, #0x0                   	// #0
    4008185c:	d2800002 	mov	x2, #0x0                   	// #0
    40081860:	940002b7 	bl	4008233c <invalid_exception_el3>
    40081864:	140001e1 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081868:	d503201f 	nop
    4008186c:	d503201f 	nop
    40081870:	d503201f 	nop
    40081874:	d503201f 	nop
    40081878:	d503201f 	nop
    4008187c:	d503201f 	nop
    INVALID_EXCP 1 0
    40081880:	d10443ff 	sub	sp, sp, #0x110
    40081884:	a90007e0 	stp	x0, x1, [sp]
    40081888:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008188c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081890:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081894:	a90427e8 	stp	x8, x9, [sp, #64]
    40081898:	a9052fea 	stp	x10, x11, [sp, #80]
    4008189c:	a90637ec 	stp	x12, x13, [sp, #96]
    400818a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400818a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400818a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400818ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400818b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400818b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400818b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400818bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400818c0:	d53c4109 	mrs	x9, sp_el1
    400818c4:	d53e402a 	mrs	x10, elr_el3
    400818c8:	d53e400b 	mrs	x11, spsr_el3
    400818cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400818d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400818d4:	910003e0 	mov	x0, sp
    400818d8:	d2800021 	mov	x1, #0x1                   	// #1
    400818dc:	d2800002 	mov	x2, #0x0                   	// #0
    400818e0:	94000297 	bl	4008233c <invalid_exception_el3>
    400818e4:	140001c1 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    400818e8:	d503201f 	nop
    400818ec:	d503201f 	nop
    400818f0:	d503201f 	nop
    400818f4:	d503201f 	nop
    400818f8:	d503201f 	nop
    400818fc:	d503201f 	nop
    INVALID_EXCP 2 0
    40081900:	d10443ff 	sub	sp, sp, #0x110
    40081904:	a90007e0 	stp	x0, x1, [sp]
    40081908:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008190c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081910:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081914:	a90427e8 	stp	x8, x9, [sp, #64]
    40081918:	a9052fea 	stp	x10, x11, [sp, #80]
    4008191c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081920:	a9073fee 	stp	x14, x15, [sp, #112]
    40081924:	a90847f0 	stp	x16, x17, [sp, #128]
    40081928:	a9094ff2 	stp	x18, x19, [sp, #144]
    4008192c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081930:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081934:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081938:	a90d6ffa 	stp	x26, x27, [sp, #208]
    4008193c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081940:	d53c4109 	mrs	x9, sp_el1
    40081944:	d53e402a 	mrs	x10, elr_el3
    40081948:	d53e400b 	mrs	x11, spsr_el3
    4008194c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081950:	a9102fea 	stp	x10, x11, [sp, #256]
    40081954:	910003e0 	mov	x0, sp
    40081958:	d2800041 	mov	x1, #0x2                   	// #2
    4008195c:	d2800002 	mov	x2, #0x0                   	// #0
    40081960:	94000277 	bl	4008233c <invalid_exception_el3>
    40081964:	140001a1 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081968:	d503201f 	nop
    4008196c:	d503201f 	nop
    40081970:	d503201f 	nop
    40081974:	d503201f 	nop
    40081978:	d503201f 	nop
    4008197c:	d503201f 	nop
    INVALID_EXCP 3 0
    40081980:	d10443ff 	sub	sp, sp, #0x110
    40081984:	a90007e0 	stp	x0, x1, [sp]
    40081988:	a9010fe2 	stp	x2, x3, [sp, #16]
    4008198c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081990:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081994:	a90427e8 	stp	x8, x9, [sp, #64]
    40081998:	a9052fea 	stp	x10, x11, [sp, #80]
    4008199c:	a90637ec 	stp	x12, x13, [sp, #96]
    400819a0:	a9073fee 	stp	x14, x15, [sp, #112]
    400819a4:	a90847f0 	stp	x16, x17, [sp, #128]
    400819a8:	a9094ff2 	stp	x18, x19, [sp, #144]
    400819ac:	a90a57f4 	stp	x20, x21, [sp, #160]
    400819b0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    400819b4:	a90c67f8 	stp	x24, x25, [sp, #192]
    400819b8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    400819bc:	a90e77fc 	stp	x28, x29, [sp, #224]
    400819c0:	d53c4109 	mrs	x9, sp_el1
    400819c4:	d53e402a 	mrs	x10, elr_el3
    400819c8:	d53e400b 	mrs	x11, spsr_el3
    400819cc:	a90f27fe 	stp	x30, x9, [sp, #240]
    400819d0:	a9102fea 	stp	x10, x11, [sp, #256]
    400819d4:	910003e0 	mov	x0, sp
    400819d8:	d2800061 	mov	x1, #0x3                   	// #3
    400819dc:	d2800002 	mov	x2, #0x0                   	// #0
    400819e0:	94000257 	bl	4008233c <invalid_exception_el3>
    400819e4:	14000181 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    400819e8:	d503201f 	nop
    400819ec:	d503201f 	nop
    400819f0:	d503201f 	nop
    400819f4:	d503201f 	nop
    400819f8:	d503201f 	nop
    400819fc:	d503201f 	nop

    // current EL, with SP_ELx
    HANDLE_SYNC
    40081a00:	d10443ff 	sub	sp, sp, #0x110
    40081a04:	a90007e0 	stp	x0, x1, [sp]
    40081a08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081a0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081a10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081a14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081a18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081a1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081a20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081a24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081a28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081a2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081a30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081a34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081a38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081a3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081a40:	d53c4109 	mrs	x9, sp_el1
    40081a44:	d53e402a 	mrs	x10, elr_el3
    40081a48:	d53e400b 	mrs	x11, spsr_el3
    40081a4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081a50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081a54:	910003e0 	mov	x0, sp
    40081a58:	940001f0 	bl	40082218 <handle_sync_exception_el3>
    40081a5c:	14000163 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081a60:	d503201f 	nop
    40081a64:	d503201f 	nop
    40081a68:	d503201f 	nop
    40081a6c:	d503201f 	nop
    40081a70:	d503201f 	nop
    40081a74:	d503201f 	nop
    40081a78:	d503201f 	nop
    40081a7c:	d503201f 	nop
    HANDLE_IRQ
    40081a80:	d10443ff 	sub	sp, sp, #0x110
    40081a84:	a90007e0 	stp	x0, x1, [sp]
    40081a88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081a8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081a90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081a94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081a98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081a9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081aa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081aa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081aa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081aac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081ab0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081ab4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081ab8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081abc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081ac0:	d53c4109 	mrs	x9, sp_el1
    40081ac4:	d53e402a 	mrs	x10, elr_el3
    40081ac8:	d53e400b 	mrs	x11, spsr_el3
    40081acc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081ad0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081ad4:	910003e0 	mov	x0, sp
    40081ad8:	9400020c 	bl	40082308 <handle_irq_exception_el3>
    40081adc:	14000143 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081ae0:	d503201f 	nop
    40081ae4:	d503201f 	nop
    40081ae8:	d503201f 	nop
    40081aec:	d503201f 	nop
    40081af0:	d503201f 	nop
    40081af4:	d503201f 	nop
    40081af8:	d503201f 	nop
    40081afc:	d503201f 	nop
    INVALID_EXCP 2 1
    40081b00:	d10443ff 	sub	sp, sp, #0x110
    40081b04:	a90007e0 	stp	x0, x1, [sp]
    40081b08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081b0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081b10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081b14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081b18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081b1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081b20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081b24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081b28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081b2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081b30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081b34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081b38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081b3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081b40:	d53c4109 	mrs	x9, sp_el1
    40081b44:	d53e402a 	mrs	x10, elr_el3
    40081b48:	d53e400b 	mrs	x11, spsr_el3
    40081b4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081b50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081b54:	910003e0 	mov	x0, sp
    40081b58:	d2800041 	mov	x1, #0x2                   	// #2
    40081b5c:	d2800022 	mov	x2, #0x1                   	// #1
    40081b60:	940001f7 	bl	4008233c <invalid_exception_el3>
    40081b64:	14000121 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081b68:	d503201f 	nop
    40081b6c:	d503201f 	nop
    40081b70:	d503201f 	nop
    40081b74:	d503201f 	nop
    40081b78:	d503201f 	nop
    40081b7c:	d503201f 	nop
    INVALID_EXCP 3 1
    40081b80:	d10443ff 	sub	sp, sp, #0x110
    40081b84:	a90007e0 	stp	x0, x1, [sp]
    40081b88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081b8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081b90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081b94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081b98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081b9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ba0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ba4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ba8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081bac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081bb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081bb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081bb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081bbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081bc0:	d53c4109 	mrs	x9, sp_el1
    40081bc4:	d53e402a 	mrs	x10, elr_el3
    40081bc8:	d53e400b 	mrs	x11, spsr_el3
    40081bcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081bd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081bd4:	910003e0 	mov	x0, sp
    40081bd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081bdc:	d2800022 	mov	x2, #0x1                   	// #1
    40081be0:	940001d7 	bl	4008233c <invalid_exception_el3>
    40081be4:	14000101 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081be8:	d503201f 	nop
    40081bec:	d503201f 	nop
    40081bf0:	d503201f 	nop
    40081bf4:	d503201f 	nop
    40081bf8:	d503201f 	nop
    40081bfc:	d503201f 	nop

    // lower EL, aarch64
    HANDLE_SYNC
    40081c00:	d10443ff 	sub	sp, sp, #0x110
    40081c04:	a90007e0 	stp	x0, x1, [sp]
    40081c08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081c0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081c10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081c14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081c18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081c1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081c20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081c24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081c28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081c2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081c30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081c34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081c38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081c3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081c40:	d53c4109 	mrs	x9, sp_el1
    40081c44:	d53e402a 	mrs	x10, elr_el3
    40081c48:	d53e400b 	mrs	x11, spsr_el3
    40081c4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081c50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081c54:	910003e0 	mov	x0, sp
    40081c58:	94000170 	bl	40082218 <handle_sync_exception_el3>
    40081c5c:	140000e3 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081c60:	d503201f 	nop
    40081c64:	d503201f 	nop
    40081c68:	d503201f 	nop
    40081c6c:	d503201f 	nop
    40081c70:	d503201f 	nop
    40081c74:	d503201f 	nop
    40081c78:	d503201f 	nop
    40081c7c:	d503201f 	nop
    HANDLE_IRQ
    40081c80:	d10443ff 	sub	sp, sp, #0x110
    40081c84:	a90007e0 	stp	x0, x1, [sp]
    40081c88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081c8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081c90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081c94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081c98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081c9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ca0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ca4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ca8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081cac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081cb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081cb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081cb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081cbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081cc0:	d53c4109 	mrs	x9, sp_el1
    40081cc4:	d53e402a 	mrs	x10, elr_el3
    40081cc8:	d53e400b 	mrs	x11, spsr_el3
    40081ccc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081cd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081cd4:	910003e0 	mov	x0, sp
    40081cd8:	9400018c 	bl	40082308 <handle_irq_exception_el3>
    40081cdc:	140000c3 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081ce0:	d503201f 	nop
    40081ce4:	d503201f 	nop
    40081ce8:	d503201f 	nop
    40081cec:	d503201f 	nop
    40081cf0:	d503201f 	nop
    40081cf4:	d503201f 	nop
    40081cf8:	d503201f 	nop
    40081cfc:	d503201f 	nop
    INVALID_EXCP 2 2
    40081d00:	d10443ff 	sub	sp, sp, #0x110
    40081d04:	a90007e0 	stp	x0, x1, [sp]
    40081d08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081d0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081d10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081d14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081d18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081d1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081d20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081d24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081d28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081d2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081d30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081d34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081d38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081d3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081d40:	d53c4109 	mrs	x9, sp_el1
    40081d44:	d53e402a 	mrs	x10, elr_el3
    40081d48:	d53e400b 	mrs	x11, spsr_el3
    40081d4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081d50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081d54:	910003e0 	mov	x0, sp
    40081d58:	d2800041 	mov	x1, #0x2                   	// #2
    40081d5c:	d2800042 	mov	x2, #0x2                   	// #2
    40081d60:	94000177 	bl	4008233c <invalid_exception_el3>
    40081d64:	140000a1 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081d68:	d503201f 	nop
    40081d6c:	d503201f 	nop
    40081d70:	d503201f 	nop
    40081d74:	d503201f 	nop
    40081d78:	d503201f 	nop
    40081d7c:	d503201f 	nop
    INVALID_EXCP 3 2
    40081d80:	d10443ff 	sub	sp, sp, #0x110
    40081d84:	a90007e0 	stp	x0, x1, [sp]
    40081d88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081d8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081d90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081d94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081d98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081d9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081da0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081da4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081da8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081dac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081db0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081db4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081db8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081dbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081dc0:	d53c4109 	mrs	x9, sp_el1
    40081dc4:	d53e402a 	mrs	x10, elr_el3
    40081dc8:	d53e400b 	mrs	x11, spsr_el3
    40081dcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081dd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081dd4:	910003e0 	mov	x0, sp
    40081dd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081ddc:	d2800042 	mov	x2, #0x2                   	// #2
    40081de0:	94000157 	bl	4008233c <invalid_exception_el3>
    40081de4:	14000081 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081de8:	d503201f 	nop
    40081dec:	d503201f 	nop
    40081df0:	d503201f 	nop
    40081df4:	d503201f 	nop
    40081df8:	d503201f 	nop
    40081dfc:	d503201f 	nop

    // lower EL, aarch32
    INVALID_EXCP 0 3
    40081e00:	d10443ff 	sub	sp, sp, #0x110
    40081e04:	a90007e0 	stp	x0, x1, [sp]
    40081e08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081e0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081e10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081e14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081e18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081e1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081e20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081e24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081e28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081e2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081e30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081e34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081e38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081e3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081e40:	d53c4109 	mrs	x9, sp_el1
    40081e44:	d53e402a 	mrs	x10, elr_el3
    40081e48:	d53e400b 	mrs	x11, spsr_el3
    40081e4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081e50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081e54:	910003e0 	mov	x0, sp
    40081e58:	d2800001 	mov	x1, #0x0                   	// #0
    40081e5c:	d2800062 	mov	x2, #0x3                   	// #3
    40081e60:	94000137 	bl	4008233c <invalid_exception_el3>
    40081e64:	14000061 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081e68:	d503201f 	nop
    40081e6c:	d503201f 	nop
    40081e70:	d503201f 	nop
    40081e74:	d503201f 	nop
    40081e78:	d503201f 	nop
    40081e7c:	d503201f 	nop
    INVALID_EXCP 1 3
    40081e80:	d10443ff 	sub	sp, sp, #0x110
    40081e84:	a90007e0 	stp	x0, x1, [sp]
    40081e88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081e8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081e90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081e94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081e98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081e9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081ea0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081ea4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081ea8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081eac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081eb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081eb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081eb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081ebc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081ec0:	d53c4109 	mrs	x9, sp_el1
    40081ec4:	d53e402a 	mrs	x10, elr_el3
    40081ec8:	d53e400b 	mrs	x11, spsr_el3
    40081ecc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081ed0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081ed4:	910003e0 	mov	x0, sp
    40081ed8:	d2800021 	mov	x1, #0x1                   	// #1
    40081edc:	d2800062 	mov	x2, #0x3                   	// #3
    40081ee0:	94000117 	bl	4008233c <invalid_exception_el3>
    40081ee4:	14000041 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081ee8:	d503201f 	nop
    40081eec:	d503201f 	nop
    40081ef0:	d503201f 	nop
    40081ef4:	d503201f 	nop
    40081ef8:	d503201f 	nop
    40081efc:	d503201f 	nop
    INVALID_EXCP 2 3
    40081f00:	d10443ff 	sub	sp, sp, #0x110
    40081f04:	a90007e0 	stp	x0, x1, [sp]
    40081f08:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081f0c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081f10:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081f14:	a90427e8 	stp	x8, x9, [sp, #64]
    40081f18:	a9052fea 	stp	x10, x11, [sp, #80]
    40081f1c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081f20:	a9073fee 	stp	x14, x15, [sp, #112]
    40081f24:	a90847f0 	stp	x16, x17, [sp, #128]
    40081f28:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081f2c:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081f30:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081f34:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081f38:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081f3c:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081f40:	d53c4109 	mrs	x9, sp_el1
    40081f44:	d53e402a 	mrs	x10, elr_el3
    40081f48:	d53e400b 	mrs	x11, spsr_el3
    40081f4c:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081f50:	a9102fea 	stp	x10, x11, [sp, #256]
    40081f54:	910003e0 	mov	x0, sp
    40081f58:	d2800041 	mov	x1, #0x2                   	// #2
    40081f5c:	d2800062 	mov	x2, #0x3                   	// #3
    40081f60:	940000f7 	bl	4008233c <invalid_exception_el3>
    40081f64:	14000021 	b	40081fe8 <exception_vector_base_el3+0x7e8>
    40081f68:	d503201f 	nop
    40081f6c:	d503201f 	nop
    40081f70:	d503201f 	nop
    40081f74:	d503201f 	nop
    40081f78:	d503201f 	nop
    40081f7c:	d503201f 	nop
    INVALID_EXCP 3 3
    40081f80:	d10443ff 	sub	sp, sp, #0x110
    40081f84:	a90007e0 	stp	x0, x1, [sp]
    40081f88:	a9010fe2 	stp	x2, x3, [sp, #16]
    40081f8c:	a90217e4 	stp	x4, x5, [sp, #32]
    40081f90:	a9031fe6 	stp	x6, x7, [sp, #48]
    40081f94:	a90427e8 	stp	x8, x9, [sp, #64]
    40081f98:	a9052fea 	stp	x10, x11, [sp, #80]
    40081f9c:	a90637ec 	stp	x12, x13, [sp, #96]
    40081fa0:	a9073fee 	stp	x14, x15, [sp, #112]
    40081fa4:	a90847f0 	stp	x16, x17, [sp, #128]
    40081fa8:	a9094ff2 	stp	x18, x19, [sp, #144]
    40081fac:	a90a57f4 	stp	x20, x21, [sp, #160]
    40081fb0:	a90b5ff6 	stp	x22, x23, [sp, #176]
    40081fb4:	a90c67f8 	stp	x24, x25, [sp, #192]
    40081fb8:	a90d6ffa 	stp	x26, x27, [sp, #208]
    40081fbc:	a90e77fc 	stp	x28, x29, [sp, #224]
    40081fc0:	d53c4109 	mrs	x9, sp_el1
    40081fc4:	d53e402a 	mrs	x10, elr_el3
    40081fc8:	d53e400b 	mrs	x11, spsr_el3
    40081fcc:	a90f27fe 	stp	x30, x9, [sp, #240]
    40081fd0:	a9102fea 	stp	x10, x11, [sp, #256]
    40081fd4:	910003e0 	mov	x0, sp
    40081fd8:	d2800061 	mov	x1, #0x3                   	// #3
    40081fdc:	d2800062 	mov	x2, #0x3                   	// #3
    40081fe0:	940000d7 	bl	4008233c <invalid_exception_el3>
    40081fe4:	14000001 	b	40081fe8 <exception_vector_base_el3+0x7e8>

.Lexception_return:
    RESTORE_REGS
    40081fe8:	a9502fea 	ldp	x10, x11, [sp, #256]
    40081fec:	a94f27fe 	ldp	x30, x9, [sp, #240]
    40081ff0:	d51c4109 	msr	sp_el1, x9
    40081ff4:	d51e402a 	msr	elr_el3, x10
    40081ff8:	d51e400b 	msr	spsr_el3, x11
    40081ffc:	a94e77fc 	ldp	x28, x29, [sp, #224]
    40082000:	a94d6ffa 	ldp	x26, x27, [sp, #208]
    40082004:	a94c67f8 	ldp	x24, x25, [sp, #192]
    40082008:	a94b5ff6 	ldp	x22, x23, [sp, #176]
    4008200c:	a94a57f4 	ldp	x20, x21, [sp, #160]
    40082010:	a9494ff2 	ldp	x18, x19, [sp, #144]
    40082014:	a94847f0 	ldp	x16, x17, [sp, #128]
    40082018:	a9473fee 	ldp	x14, x15, [sp, #112]
    4008201c:	a94637ec 	ldp	x12, x13, [sp, #96]
    40082020:	a9452fea 	ldp	x10, x11, [sp, #80]
    40082024:	a94427e8 	ldp	x8, x9, [sp, #64]
    40082028:	a9431fe6 	ldp	x6, x7, [sp, #48]
    4008202c:	a94217e4 	ldp	x4, x5, [sp, #32]
    40082030:	a9410fe2 	ldp	x2, x3, [sp, #16]
    40082034:	a94007e0 	ldp	x0, x1, [sp]
    40082038:	910443ff 	add	sp, sp, #0x110
    eret
    4008203c:	d69f03e0 	eret

0000000040082040 <trigger_exception>:

.global trigger_exception
trigger_exception:
    ldr x0, =0xFFFFFFFF
    40082040:	58000080 	ldr	x0, 40082050 <trigger_exception+0x10>
    ldr x1, [x0] // 触发数据中止异常
    40082044:	f9400001 	ldr	x1, [x0]
    ret
    40082048:	d65f03c0 	ret
    4008204c:	00000000 	udf	#0
    40082050:	ffffffff 	.word	0xffffffff
    40082054:	00000000 	.word	0x00000000

0000000040082058 <read_esr_el1>:
#include <io.h>
#include <exception_frame.h>
#include <gic.h>

static inline uint32_t read_esr_el1(void)
{
    40082058:	d10043ff 	sub	sp, sp, #0x10
    uint32_t esr;

    // 使用内联汇编读取 ESR_EL1 寄存器
    __asm__ volatile ("mrs %0, esr_el1" : "=r" (esr));
    4008205c:	d5385200 	mrs	x0, esr_el1
    40082060:	f90007e0 	str	x0, [sp, #8]

    return esr;
    40082064:	f94007e0 	ldr	x0, [sp, #8]
}
    40082068:	910043ff 	add	sp, sp, #0x10
    4008206c:	d65f03c0 	ret

0000000040082070 <handle_sync_exception>:

// 示例使用方式：处理同步异常
void handle_sync_exception(uint64_t *stack_pointer) {
    40082070:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    40082074:	910003fd 	mov	x29, sp
    40082078:	f9000fe0 	str	x0, [sp, #24]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    4008207c:	f9400fe0 	ldr	x0, [sp, #24]
    40082080:	f9002be0 	str	x0, [sp, #80]

    int el1_esr = read_esr_el1();
    40082084:	97fffff5 	bl	40082058 <read_esr_el1>
    40082088:	b9004fe0 	str	w0, [sp, #76]

    int ec = (( el1_esr >> 26) & 0b111111);
    4008208c:	b9404fe0 	ldr	w0, [sp, #76]
    40082090:	531a7c00 	lsr	w0, w0, #26
    40082094:	b9004be0 	str	w0, [sp, #72]

    printf("el1 esr: %x\n", el1_esr);
    40082098:	b9404fe1 	ldr	w1, [sp, #76]
    4008209c:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400820a0:	910b8000 	add	x0, x0, #0x2e0
    400820a4:	940005d4 	bl	400837f4 <printf>
    printf("ec: %x\n", ec);
    400820a8:	b9404be1 	ldr	w1, [sp, #72]
    400820ac:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400820b0:	910bc000 	add	x0, x0, #0x2f0
    400820b4:	940005d0 	bl	400837f4 <printf>
    

    if ( ec == 0x17 ) {  // smc
    400820b8:	b9404be0 	ldr	w0, [sp, #72]
    400820bc:	71005c1f 	cmp	w0, #0x17
    400820c0:	540000a1 	b.ne	400820d4 <handle_sync_exception+0x64>  // b.any
        printf("This is smc call handler\n");
    400820c4:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400820c8:	910be000 	add	x0, x0, #0x2f8
    400820cc:	940005ca 	bl	400837f4 <printf>
        return;
    400820d0:	14000025 	b	40082164 <handle_sync_exception+0xf4>
    }

    printf("This is handle_sync_exception: \n");
    400820d4:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400820d8:	910c6000 	add	x0, x0, #0x318
    400820dc:	940005c6 	bl	400837f4 <printf>
    for(int i=0; i<31; i++) {
    400820e0:	b9005fff 	str	wzr, [sp, #92]
    400820e4:	1400000d 	b	40082118 <handle_sync_exception+0xa8>
        uint64_t value = context->r[i];
    400820e8:	f9402be0 	ldr	x0, [sp, #80]
    400820ec:	b9805fe1 	ldrsw	x1, [sp, #92]
    400820f0:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    400820f4:	f90017e0 	str	x0, [sp, #40]
        printf("General-purpose register: %d, value: %x\n", i, value);
    400820f8:	f94017e2 	ldr	x2, [sp, #40]
    400820fc:	b9405fe1 	ldr	w1, [sp, #92]
    40082100:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    40082104:	910d0000 	add	x0, x0, #0x340
    40082108:	940005bb 	bl	400837f4 <printf>
    for(int i=0; i<31; i++) {
    4008210c:	b9405fe0 	ldr	w0, [sp, #92]
    40082110:	11000400 	add	w0, w0, #0x1
    40082114:	b9005fe0 	str	w0, [sp, #92]
    40082118:	b9405fe0 	ldr	w0, [sp, #92]
    4008211c:	7100781f 	cmp	w0, #0x1e
    40082120:	54fffe4d 	b.le	400820e8 <handle_sync_exception+0x78>
    }
    
    uint64_t elr_el1_value = context->elr;
    40082124:	f9402be0 	ldr	x0, [sp, #80]
    40082128:	f9408000 	ldr	x0, [x0, #256]
    4008212c:	f90023e0 	str	x0, [sp, #64]
    uint64_t usp_value = context->usp;
    40082130:	f9402be0 	ldr	x0, [sp, #80]
    40082134:	f9407c00 	ldr	x0, [x0, #248]
    40082138:	f9001fe0 	str	x0, [sp, #56]
    uint64_t spsr_value = context->spsr;
    4008213c:	f9402be0 	ldr	x0, [sp, #80]
    40082140:	f9408400 	ldr	x0, [x0, #264]
    40082144:	f9001be0 	str	x0, [sp, #48]

    printf("usp: %x, elr: %x, spsr: %x\n", usp_value, elr_el1_value, spsr_value);
    40082148:	f9401be3 	ldr	x3, [sp, #48]
    4008214c:	f94023e2 	ldr	x2, [sp, #64]
    40082150:	f9401fe1 	ldr	x1, [sp, #56]
    40082154:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    40082158:	910dc000 	add	x0, x0, #0x370
    4008215c:	940005a6 	bl	400837f4 <printf>

    while(1);
    40082160:	14000000 	b	40082160 <handle_sync_exception+0xf0>
}
    40082164:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40082168:	d65f03c0 	ret

000000004008216c <handle_irq_exception>:

// 示例使用方式：处理 IRQ 异常
void handle_irq_exception(uint64_t *stack_pointer) {
    4008216c:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    40082170:	910003fd 	mov	x29, sp
    40082174:	f9000fe0 	str	x0, [sp, #24]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    40082178:	f9400fe0 	ldr	x0, [sp, #24]
    4008217c:	f9001fe0 	str	x0, [sp, #56]

    uint64_t x1_value = context->r[1];
    40082180:	f9401fe0 	ldr	x0, [sp, #56]
    40082184:	f9400400 	ldr	x0, [x0, #8]
    40082188:	f9001be0 	str	x0, [sp, #48]
    uint64_t sp_el0_value = context->usp;
    4008218c:	f9401fe0 	ldr	x0, [sp, #56]
    40082190:	f9407c00 	ldr	x0, [x0, #248]
    40082194:	f90017e0 	str	x0, [sp, #40]

    int iar = gicv2_read_iar();
    40082198:	940000e5 	bl	4008252c <gicv2_read_iar>
    4008219c:	b90027e0 	str	w0, [sp, #36]

    if (gicv2_iar_irqnr(iar) == 33) {
    400821a0:	b98027e0 	ldrsw	x0, [sp, #36]
    400821a4:	940000eb 	bl	40082550 <gicv2_iar_irqnr>
    400821a8:	f100841f 	cmp	x0, #0x21
    400821ac:	54000081 	b.ne	400821bc <handle_irq_exception+0x50>  // b.any
        printf("this is timer event...");
    400821b0:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400821b4:	910e4000 	add	x0, x0, #0x390
    400821b8:	9400058f 	bl	400837f4 <printf>
    }

    gicv2_write_eoir(iar);
    400821bc:	b98027e0 	ldrsw	x0, [sp, #36]
    400821c0:	940000ea 	bl	40082568 <gicv2_write_eoir>

    // 在这里实现处理 IRQ 异常的代码
}
    400821c4:	d503201f 	nop
    400821c8:	a8c47bfd 	ldp	x29, x30, [sp], #64
    400821cc:	d65f03c0 	ret

00000000400821d0 <invalid_exception>:

// 示例使用方式：处理无效异常
void invalid_exception(uint64_t *stack_pointer, uint64_t kind, uint64_t source) {
    400821d0:	d100c3ff 	sub	sp, sp, #0x30
    400821d4:	f9000fe0 	str	x0, [sp, #24]
    400821d8:	f9000be1 	str	x1, [sp, #16]
    400821dc:	f90007e2 	str	x2, [sp, #8]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    400821e0:	f9400fe0 	ldr	x0, [sp, #24]
    400821e4:	f90017e0 	str	x0, [sp, #40]

    uint64_t x2_value = context->r[2];
    400821e8:	f94017e0 	ldr	x0, [sp, #40]
    400821ec:	f9400800 	ldr	x0, [x0, #16]
    400821f0:	f90013e0 	str	x0, [sp, #32]

    // 在这里实现处理无效异常的代码
    400821f4:	d503201f 	nop
    400821f8:	9100c3ff 	add	sp, sp, #0x30
    400821fc:	d65f03c0 	ret

0000000040082200 <read_esr_el3>:
#include <io.h>
#include <exception_frame.h>


static inline uint32_t read_esr_el3(void)
{
    40082200:	d10043ff 	sub	sp, sp, #0x10
    uint32_t esr;

    // 使用内联汇编读取 ESR_EL1 寄存器
    __asm__ volatile ("mrs %0, esr_el3" : "=r" (esr));
    40082204:	d53e5200 	mrs	x0, esr_el3
    40082208:	f90007e0 	str	x0, [sp, #8]

    return esr;
    4008220c:	f94007e0 	ldr	x0, [sp, #8]
}
    40082210:	910043ff 	add	sp, sp, #0x10
    40082214:	d65f03c0 	ret

0000000040082218 <handle_sync_exception_el3>:

// 示例使用方式：处理同步异常
void handle_sync_exception_el3(uint64_t *stack_pointer) {
    40082218:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
    4008221c:	910003fd 	mov	x29, sp
    40082220:	f9000fe0 	str	x0, [sp, #24]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    40082224:	f9400fe0 	ldr	x0, [sp, #24]
    40082228:	f9002be0 	str	x0, [sp, #80]

    int el3_esr = read_esr_el3();
    4008222c:	97fffff5 	bl	40082200 <read_esr_el3>
    40082230:	b9004fe0 	str	w0, [sp, #76]

    int ec = (( el3_esr >> 26) & 0b111111);
    40082234:	b9404fe0 	ldr	w0, [sp, #76]
    40082238:	531a7c00 	lsr	w0, w0, #26
    4008223c:	b9004be0 	str	w0, [sp, #72]

    printf("        el1 esr: %x\n", el3_esr);
    40082240:	b9404fe1 	ldr	w1, [sp, #76]
    40082244:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    40082248:	910ea000 	add	x0, x0, #0x3a8
    4008224c:	9400056a 	bl	400837f4 <printf>
    printf("        ec: %x\n", ec);
    40082250:	b9404be1 	ldr	w1, [sp, #72]
    40082254:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    40082258:	910f0000 	add	x0, x0, #0x3c0
    4008225c:	94000566 	bl	400837f4 <printf>
    

    if ( ec == 0x17 ) {  // smc
    40082260:	b9404be0 	ldr	w0, [sp, #72]
    40082264:	71005c1f 	cmp	w0, #0x17
    40082268:	540000a1 	b.ne	4008227c <handle_sync_exception_el3+0x64>  // b.any
        printf("            This is smc call handler\n");
    4008226c:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    40082270:	910f4000 	add	x0, x0, #0x3d0
    40082274:	94000560 	bl	400837f4 <printf>
        return;
    40082278:	14000022 	b	40082300 <handle_sync_exception_el3+0xe8>
    }

    for(int i=0; i<31; i++) {
    4008227c:	b9005fff 	str	wzr, [sp, #92]
    40082280:	1400000d 	b	400822b4 <handle_sync_exception_el3+0x9c>
        uint64_t value = context->r[i];
    40082284:	f9402be0 	ldr	x0, [sp, #80]
    40082288:	b9805fe1 	ldrsw	x1, [sp, #92]
    4008228c:	f8617800 	ldr	x0, [x0, x1, lsl #3]
    40082290:	f90017e0 	str	x0, [sp, #40]
        printf("General-purpose register: %d, value: %x\n", i, value);
    40082294:	f94017e2 	ldr	x2, [sp, #40]
    40082298:	b9405fe1 	ldr	w1, [sp, #92]
    4008229c:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400822a0:	910fe000 	add	x0, x0, #0x3f8
    400822a4:	94000554 	bl	400837f4 <printf>
    for(int i=0; i<31; i++) {
    400822a8:	b9405fe0 	ldr	w0, [sp, #92]
    400822ac:	11000400 	add	w0, w0, #0x1
    400822b0:	b9005fe0 	str	w0, [sp, #92]
    400822b4:	b9405fe0 	ldr	w0, [sp, #92]
    400822b8:	7100781f 	cmp	w0, #0x1e
    400822bc:	54fffe4d 	b.le	40082284 <handle_sync_exception_el3+0x6c>
    }
    
    uint64_t elr_el1_value = context->elr;
    400822c0:	f9402be0 	ldr	x0, [sp, #80]
    400822c4:	f9408000 	ldr	x0, [x0, #256]
    400822c8:	f90023e0 	str	x0, [sp, #64]
    uint64_t usp_value = context->usp;
    400822cc:	f9402be0 	ldr	x0, [sp, #80]
    400822d0:	f9407c00 	ldr	x0, [x0, #248]
    400822d4:	f9001fe0 	str	x0, [sp, #56]
    uint64_t spsr_value = context->spsr;
    400822d8:	f9402be0 	ldr	x0, [sp, #80]
    400822dc:	f9408400 	ldr	x0, [x0, #264]
    400822e0:	f9001be0 	str	x0, [sp, #48]

    printf("usp: %x, elr: %x, spsr: %x\n", usp_value, elr_el1_value, spsr_value);
    400822e4:	f9401be3 	ldr	x3, [sp, #48]
    400822e8:	f94023e2 	ldr	x2, [sp, #64]
    400822ec:	f9401fe1 	ldr	x1, [sp, #56]
    400822f0:	d0000000 	adrp	x0, 40084000 <memmove+0x58>
    400822f4:	9110a000 	add	x0, x0, #0x428
    400822f8:	9400053f 	bl	400837f4 <printf>

    while(1);
    400822fc:	14000000 	b	400822fc <handle_sync_exception_el3+0xe4>
}
    40082300:	a8c67bfd 	ldp	x29, x30, [sp], #96
    40082304:	d65f03c0 	ret

0000000040082308 <handle_irq_exception_el3>:

// 示例使用方式：处理 IRQ 异常
void handle_irq_exception_el3(uint64_t *stack_pointer) {
    40082308:	d100c3ff 	sub	sp, sp, #0x30
    4008230c:	f90007e0 	str	x0, [sp, #8]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    40082310:	f94007e0 	ldr	x0, [sp, #8]
    40082314:	f90017e0 	str	x0, [sp, #40]

    uint64_t x1_value = context->r[1];
    40082318:	f94017e0 	ldr	x0, [sp, #40]
    4008231c:	f9400400 	ldr	x0, [x0, #8]
    40082320:	f90013e0 	str	x0, [sp, #32]
    uint64_t sp_el0_value = context->usp;
    40082324:	f94017e0 	ldr	x0, [sp, #40]
    40082328:	f9407c00 	ldr	x0, [x0, #248]
    4008232c:	f9000fe0 	str	x0, [sp, #24]

    // 在这里实现处理 IRQ 异常的代码
}
    40082330:	d503201f 	nop
    40082334:	9100c3ff 	add	sp, sp, #0x30
    40082338:	d65f03c0 	ret

000000004008233c <invalid_exception_el3>:

// 示例使用方式：处理无效异常
void invalid_exception_el3(uint64_t *stack_pointer, uint64_t kind, uint64_t source) {
    4008233c:	d100c3ff 	sub	sp, sp, #0x30
    40082340:	f9000fe0 	str	x0, [sp, #24]
    40082344:	f9000be1 	str	x1, [sp, #16]
    40082348:	f90007e2 	str	x2, [sp, #8]
    TrapFrame *context = (TrapFrame *)stack_pointer;
    4008234c:	f9400fe0 	ldr	x0, [sp, #24]
    40082350:	f90017e0 	str	x0, [sp, #40]

    uint64_t x2_value = context->r[2];
    40082354:	f94017e0 	ldr	x0, [sp, #40]
    40082358:	f9400800 	ldr	x0, [x0, #16]
    4008235c:	f90013e0 	str	x0, [sp, #32]

    // 在这里实现处理无效异常的代码
    40082360:	d503201f 	nop
    40082364:	9100c3ff 	add	sp, sp, #0x30
    40082368:	d65f03c0 	ret

000000004008236c <readl>:
extern struct gicv2_t _gicv2;

#define gicv2_dist_base()		(_gicv2.dist_base)
#define gicv2_cpu_base()		(_gicv2.cpu_base)

static inline uint32_t readl(const volatile void *addr) {
    4008236c:	d10043ff 	sub	sp, sp, #0x10
    40082370:	f90007e0 	str	x0, [sp, #8]
    return *(const volatile uint32_t *)addr;
    40082374:	f94007e0 	ldr	x0, [sp, #8]
    40082378:	f9400000 	ldr	x0, [x0]
}
    4008237c:	910043ff 	add	sp, sp, #0x10
    40082380:	d65f03c0 	ret

0000000040082384 <writel>:

static inline void writel(uint32_t value, volatile void *addr) {
    40082384:	d10043ff 	sub	sp, sp, #0x10
    40082388:	f90007e0 	str	x0, [sp, #8]
    4008238c:	f90003e1 	str	x1, [sp]
    *(volatile uint32_t *)addr = value;
    40082390:	f94003e0 	ldr	x0, [sp]
    40082394:	f94007e1 	ldr	x1, [sp, #8]
    40082398:	f9000001 	str	x1, [x0]
}
    4008239c:	d503201f 	nop
    400823a0:	910043ff 	add	sp, sp, #0x10
    400823a4:	d65f03c0 	ret

00000000400823a8 <gicv2_init>:
struct gicv2_t _gicv2;

void gicv2_enable_defaults(void);

void gicv2_init() 
{
    400823a8:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400823ac:	910003fd 	mov	x29, sp
    _gicv2.dist_base = (void*)0x8000000;
    400823b0:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400823b4:	91000000 	add	x0, x0, #0x0
    400823b8:	d2a10001 	mov	x1, #0x8000000             	// #134217728
    400823bc:	f9000001 	str	x1, [x0]
    _gicv2.cpu_base  = (void*)0x8010000;
    400823c0:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400823c4:	91000000 	add	x0, x0, #0x0
    400823c8:	d2a10021 	mov	x1, #0x8010000             	// #134283264
    400823cc:	f9000401 	str	x1, [x0, #8]

    gicv2_enable_defaults();
    400823d0:	94000004 	bl	400823e0 <gicv2_enable_defaults>
}
    400823d4:	d503201f 	nop
    400823d8:	a8c17bfd 	ldp	x29, x30, [sp], #16
    400823dc:	d65f03c0 	ret

00000000400823e0 <gicv2_enable_defaults>:

void gicv2_enable_defaults(void)
{
    400823e0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    400823e4:	910003fd 	mov	x29, sp
	void *dist = gicv2_dist_base();
    400823e8:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400823ec:	91000000 	add	x0, x0, #0x0
    400823f0:	f9400000 	ldr	x0, [x0]
    400823f4:	f90013e0 	str	x0, [sp, #32]
	void *cpu_base = gicv2_cpu_base();
    400823f8:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400823fc:	91000000 	add	x0, x0, #0x0
    40082400:	f9400400 	ldr	x0, [x0, #8]
    40082404:	f9000fe0 	str	x0, [sp, #24]
	unsigned int i;

	_gicv2.irq_nr = GICD_TYPER_IRQS(readl(dist + GICD_TYPER));
    40082408:	f94013e0 	ldr	x0, [sp, #32]
    4008240c:	91001000 	add	x0, x0, #0x4
    40082410:	97ffffd7 	bl	4008236c <readl>
    40082414:	92401000 	and	x0, x0, #0x1f
    40082418:	91000400 	add	x0, x0, #0x1
    4008241c:	531b6801 	lsl	w1, w0, #5
    40082420:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082424:	91000000 	add	x0, x0, #0x0
    40082428:	b9001001 	str	w1, [x0, #16]
	if (_gicv2.irq_nr > 1020)
    4008242c:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082430:	91000000 	add	x0, x0, #0x0
    40082434:	b9401000 	ldr	w0, [x0, #16]
    40082438:	710ff01f 	cmp	w0, #0x3fc
    4008243c:	540000a9 	b.ls	40082450 <gicv2_enable_defaults+0x70>  // b.plast
		_gicv2.irq_nr = 1020;
    40082440:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082444:	91000000 	add	x0, x0, #0x0
    40082448:	52807f81 	mov	w1, #0x3fc                 	// #1020
    4008244c:	b9001001 	str	w1, [x0, #16]

	for (i = 0; i < _gicv2.irq_nr; i += 4)
    40082450:	b9002fff 	str	wzr, [sp, #44]
    40082454:	1400000c 	b	40082484 <gicv2_enable_defaults+0xa4>
		writel(GICD_INT_DEF_PRI_X4, dist + GICD_IPRIORITYR + i);
    40082458:	b9402fe0 	ldr	w0, [sp, #44]
    4008245c:	91100000 	add	x0, x0, #0x400
    40082460:	f94013e1 	ldr	x1, [sp, #32]
    40082464:	8b000020 	add	x0, x1, x0
    40082468:	aa0003e1 	mov	x1, x0
    4008246c:	d2941400 	mov	x0, #0xa0a0                	// #41120
    40082470:	f2b41400 	movk	x0, #0xa0a0, lsl #16
    40082474:	97ffffc4 	bl	40082384 <writel>
	for (i = 0; i < _gicv2.irq_nr; i += 4)
    40082478:	b9402fe0 	ldr	w0, [sp, #44]
    4008247c:	11001000 	add	w0, w0, #0x4
    40082480:	b9002fe0 	str	w0, [sp, #44]
    40082484:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082488:	91000000 	add	x0, x0, #0x0
    4008248c:	b9401000 	ldr	w0, [x0, #16]
    40082490:	b9402fe1 	ldr	w1, [sp, #44]
    40082494:	6b00003f 	cmp	w1, w0
    40082498:	54fffe03 	b.cc	40082458 <gicv2_enable_defaults+0x78>  // b.lo, b.ul, b.last

	writel(GICD_INT_EN_SET_SGI, dist + GICD_ISENABLER + 0);
    4008249c:	f94013e0 	ldr	x0, [sp, #32]
    400824a0:	91040000 	add	x0, x0, #0x100
    400824a4:	aa0003e1 	mov	x1, x0
    400824a8:	d29fffe0 	mov	x0, #0xffff                	// #65535
    400824ac:	97ffffb6 	bl	40082384 <writel>
	writel(GICD_ENABLE, dist + GICD_CTLR);
    400824b0:	f94013e1 	ldr	x1, [sp, #32]
    400824b4:	d2800020 	mov	x0, #0x1                   	// #1
    400824b8:	97ffffb3 	bl	40082384 <writel>

	writel(GICC_INT_PRI_THRESHOLD, cpu_base + GICC_PMR);
    400824bc:	f9400fe0 	ldr	x0, [sp, #24]
    400824c0:	91001000 	add	x0, x0, #0x4
    400824c4:	aa0003e1 	mov	x1, x0
    400824c8:	d2801e00 	mov	x0, #0xf0                  	// #240
    400824cc:	97ffffae 	bl	40082384 <writel>
	writel(GICC_ENABLE, cpu_base + GICC_CTLR);
    400824d0:	f9400fe1 	ldr	x1, [sp, #24]
    400824d4:	d2800020 	mov	x0, #0x1                   	// #1
    400824d8:	97ffffab 	bl	40082384 <writel>
}
    400824dc:	d503201f 	nop
    400824e0:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400824e4:	d65f03c0 	ret

00000000400824e8 <gicv2_enable_defaults_second>:

void gicv2_enable_defaults_second() 
{
    400824e8:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400824ec:	910003fd 	mov	x29, sp
    void *cpu_base = gicv2_cpu_base();
    400824f0:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400824f4:	91000000 	add	x0, x0, #0x0
    400824f8:	f9400400 	ldr	x0, [x0, #8]
    400824fc:	f9000fe0 	str	x0, [sp, #24]
    writel(GICC_INT_PRI_THRESHOLD, cpu_base + GICC_PMR);
    40082500:	f9400fe0 	ldr	x0, [sp, #24]
    40082504:	91001000 	add	x0, x0, #0x4
    40082508:	aa0003e1 	mov	x1, x0
    4008250c:	d2801e00 	mov	x0, #0xf0                  	// #240
    40082510:	97ffff9d 	bl	40082384 <writel>
	writel(GICC_ENABLE, cpu_base + GICC_CTLR);
    40082514:	f9400fe1 	ldr	x1, [sp, #24]
    40082518:	d2800020 	mov	x0, #0x1                   	// #1
    4008251c:	97ffff9a 	bl	40082384 <writel>
}
    40082520:	d503201f 	nop
    40082524:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40082528:	d65f03c0 	ret

000000004008252c <gicv2_read_iar>:

uint32_t gicv2_read_iar(void)
{
    4008252c:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40082530:	910003fd 	mov	x29, sp
	return readl(gicv2_cpu_base() + GICC_IAR);
    40082534:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082538:	91000000 	add	x0, x0, #0x0
    4008253c:	f9400400 	ldr	x0, [x0, #8]
    40082540:	91003000 	add	x0, x0, #0xc
    40082544:	97ffff8a 	bl	4008236c <readl>
}
    40082548:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4008254c:	d65f03c0 	ret

0000000040082550 <gicv2_iar_irqnr>:

uint32_t gicv2_iar_irqnr(uint32_t iar)
{
    40082550:	d10043ff 	sub	sp, sp, #0x10
    40082554:	f90007e0 	str	x0, [sp, #8]
	return iar & GICC_IAR_INT_ID_MASK;
    40082558:	f94007e0 	ldr	x0, [sp, #8]
    4008255c:	92402400 	and	x0, x0, #0x3ff
}
    40082560:	910043ff 	add	sp, sp, #0x10
    40082564:	d65f03c0 	ret

0000000040082568 <gicv2_write_eoir>:

void gicv2_write_eoir(uint32_t irqstat)
{
    40082568:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    4008256c:	910003fd 	mov	x29, sp
    40082570:	f9000fe0 	str	x0, [sp, #24]
	writel(irqstat, gicv2_cpu_base() + GICC_EOIR);
    40082574:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082578:	91000000 	add	x0, x0, #0x0
    4008257c:	f9400400 	ldr	x0, [x0, #8]
    40082580:	91004000 	add	x0, x0, #0x10
    40082584:	aa0003e1 	mov	x1, x0
    40082588:	f9400fe0 	ldr	x0, [sp, #24]
    4008258c:	97ffff7e 	bl	40082384 <writel>
}
    40082590:	d503201f 	nop
    40082594:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40082598:	d65f03c0 	ret

000000004008259c <gicv2_ipi_send_single>:


void gicv2_ipi_send_single(int irq, int cpu)
{
    4008259c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400825a0:	910003fd 	mov	x29, sp
    400825a4:	b9001fe0 	str	w0, [sp, #28]
    400825a8:	b9001be1 	str	w1, [sp, #24]
	//assert(cpu < 8);
	//assert(irq < 16);
	writel(1 << (cpu + 16) | irq, gicv2_dist_base() + GICD_SGIR);
    400825ac:	b9401be0 	ldr	w0, [sp, #24]
    400825b0:	11004000 	add	w0, w0, #0x10
    400825b4:	52800021 	mov	w1, #0x1                   	// #1
    400825b8:	1ac02021 	lsl	w1, w1, w0
    400825bc:	b9401fe0 	ldr	w0, [sp, #28]
    400825c0:	2a000020 	orr	w0, w1, w0
    400825c4:	93407c02 	sxtw	x2, w0
    400825c8:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400825cc:	91000000 	add	x0, x0, #0x0
    400825d0:	f9400000 	ldr	x0, [x0]
    400825d4:	913c0000 	add	x0, x0, #0xf00
    400825d8:	aa0003e1 	mov	x1, x0
    400825dc:	aa0203e0 	mov	x0, x2
    400825e0:	97ffff69 	bl	40082384 <writel>
}
    400825e4:	d503201f 	nop
    400825e8:	a8c27bfd 	ldp	x29, x30, [sp], #32
    400825ec:	d65f03c0 	ret

00000000400825f0 <cpu_num>:

// The number of implemented CPU interfaces.
uint32_t cpu_num() {
    400825f0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    400825f4:	910003fd 	mov	x29, sp
    return GICD_TYPER_CPU_NUM(readl(gicv2_dist_base() + GICD_TYPER));
    400825f8:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400825fc:	91000000 	add	x0, x0, #0x0
    40082600:	f9400000 	ldr	x0, [x0]
    40082604:	91001000 	add	x0, x0, #0x4
    40082608:	97ffff59 	bl	4008236c <readl>
    4008260c:	d345fc00 	lsr	x0, x0, #5
    40082610:	92400800 	and	x0, x0, #0x7
    40082614:	91000400 	add	x0, x0, #0x1
}
    40082618:	a8c17bfd 	ldp	x29, x30, [sp], #16
    4008261c:	d65f03c0 	ret

0000000040082620 <configure_interrupt>:


// Configures the trigger mode for the given interrupt.
void configure_interrupt(int vector, trigger_mode_t tg) 
{
    40082620:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40082624:	910003fd 	mov	x29, sp
    40082628:	b9001fe0 	str	w0, [sp, #28]
    4008262c:	b9001be1 	str	w1, [sp, #24]
    // Only configurable for SPI interrupts
    if (vector >= _gicv2.irq_nr || vector < 32) {
    40082630:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082634:	91000000 	add	x0, x0, #0x0
    40082638:	b9401001 	ldr	w1, [x0, #16]
    4008263c:	b9401fe0 	ldr	w0, [sp, #28]
    40082640:	6b00003f 	cmp	w1, w0
    40082644:	540006a9 	b.ls	40082718 <configure_interrupt+0xf8>  // b.plast
    40082648:	b9401fe0 	ldr	w0, [sp, #28]
    4008264c:	71007c1f 	cmp	w0, #0x1f
    40082650:	5400064d 	b.le	40082718 <configure_interrupt+0xf8>
        return;
    }

    // type is encoded with two bits, MSB of the two determine type
    // 16 irqs encoded per ICFGR register
    int reg_idx = vector >> 4;
    40082654:	b9401fe0 	ldr	w0, [sp, #28]
    40082658:	13047c00 	asr	w0, w0, #4
    4008265c:	b9002be0 	str	w0, [sp, #40]
    int bit_shift = ((vector & 0xf) << 1) + 1;
    40082660:	b9401fe0 	ldr	w0, [sp, #28]
    40082664:	531f7800 	lsl	w0, w0, #1
    40082668:	121f0c00 	and	w0, w0, #0x1e
    4008266c:	11000400 	add	w0, w0, #0x1
    40082670:	b90027e0 	str	w0, [sp, #36]
    int reg_val = readl( (gicv2_dist_base() + GICD_ICFGR + reg_idx * sizeof(int)));
    40082674:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082678:	91000000 	add	x0, x0, #0x0
    4008267c:	f9400001 	ldr	x1, [x0]
    40082680:	b9802be0 	ldrsw	x0, [sp, #40]
    40082684:	910c0000 	add	x0, x0, #0x300
    40082688:	d37ef400 	lsl	x0, x0, #2
    4008268c:	8b000020 	add	x0, x1, x0
    40082690:	97ffff37 	bl	4008236c <readl>
    40082694:	b9002fe0 	str	w0, [sp, #44]
    if (tg == EDGE) {
    40082698:	b9401be0 	ldr	w0, [sp, #24]
    4008269c:	7100041f 	cmp	w0, #0x1
    400826a0:	54000101 	b.ne	400826c0 <configure_interrupt+0xa0>  // b.any
        reg_val |= 1 << bit_shift;
    400826a4:	b94027e0 	ldr	w0, [sp, #36]
    400826a8:	52800021 	mov	w1, #0x1                   	// #1
    400826ac:	1ac02020 	lsl	w0, w1, w0
    400826b0:	b9402fe1 	ldr	w1, [sp, #44]
    400826b4:	2a000020 	orr	w0, w1, w0
    400826b8:	b9002fe0 	str	w0, [sp, #44]
    400826bc:	1400000b 	b	400826e8 <configure_interrupt+0xc8>
    } else {
        reg_val &= !(1 << bit_shift);
    400826c0:	b94027e0 	ldr	w0, [sp, #36]
    400826c4:	52800021 	mov	w1, #0x1                   	// #1
    400826c8:	1ac02020 	lsl	w0, w1, w0
    400826cc:	7100001f 	cmp	w0, #0x0
    400826d0:	1a9f17e0 	cset	w0, eq  // eq = none
    400826d4:	12001c00 	and	w0, w0, #0xff
    400826d8:	2a0003e1 	mov	w1, w0
    400826dc:	b9402fe0 	ldr	w0, [sp, #44]
    400826e0:	0a010000 	and	w0, w0, w1
    400826e4:	b9002fe0 	str	w0, [sp, #44]
    }
    writel(reg_val, (gicv2_dist_base() + GICD_ICFGR + reg_idx * sizeof(int)));
    400826e8:	b9802fe2 	ldrsw	x2, [sp, #44]
    400826ec:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400826f0:	91000000 	add	x0, x0, #0x0
    400826f4:	f9400001 	ldr	x1, [x0]
    400826f8:	b9802be0 	ldrsw	x0, [sp, #40]
    400826fc:	910c0000 	add	x0, x0, #0x300
    40082700:	d37ef400 	lsl	x0, x0, #2
    40082704:	8b000020 	add	x0, x1, x0
    40082708:	aa0003e1 	mov	x1, x0
    4008270c:	aa0203e0 	mov	x0, x2
    40082710:	97ffff1d 	bl	40082384 <writel>
    40082714:	14000002 	b	4008271c <configure_interrupt+0xfc>
        return;
    40082718:	d503201f 	nop
}
    4008271c:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40082720:	d65f03c0 	ret

0000000040082724 <set_enable>:

// Enables or disables the given interrupt.
void set_enable(int vector, bool enable) 
{
    40082724:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40082728:	910003fd 	mov	x29, sp
    4008272c:	b9001fe0 	str	w0, [sp, #28]
    40082730:	39006fe1 	strb	w1, [sp, #27]
    if (vector >= _gicv2.irq_nr) {
    40082734:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    40082738:	91000000 	add	x0, x0, #0x0
    4008273c:	b9401001 	ldr	w1, [x0, #16]
    40082740:	b9401fe0 	ldr	w0, [sp, #28]
    40082744:	6b00003f 	cmp	w1, w0
    40082748:	540004e9 	b.ls	400827e4 <set_enable+0xc0>  // b.plast
        return;
    }
    int reg = vector / 32;
    4008274c:	b9401fe0 	ldr	w0, [sp, #28]
    40082750:	11007c01 	add	w1, w0, #0x1f
    40082754:	7100001f 	cmp	w0, #0x0
    40082758:	1a80b020 	csel	w0, w1, w0, lt  // lt = tstop
    4008275c:	13057c00 	asr	w0, w0, #5
    40082760:	b9002fe0 	str	w0, [sp, #44]
    int mask = 1 << (vector % 32);
    40082764:	b9401fe0 	ldr	w0, [sp, #28]
    40082768:	12001000 	and	w0, w0, #0x1f
    4008276c:	52800021 	mov	w1, #0x1                   	// #1
    40082770:	1ac02020 	lsl	w0, w1, w0
    40082774:	b9002be0 	str	w0, [sp, #40]
    if (enable) {
    40082778:	39406fe0 	ldrb	w0, [sp, #27]
    4008277c:	7100001f 	cmp	w0, #0x0
    40082780:	540001a0 	b.eq	400827b4 <set_enable+0x90>  // b.none
        writel(mask, (gicv2_dist_base() + GICD_ISENABLER + reg * sizeof(int)));
    40082784:	b9802be2 	ldrsw	x2, [sp, #40]
    40082788:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    4008278c:	91000000 	add	x0, x0, #0x0
    40082790:	f9400001 	ldr	x1, [x0]
    40082794:	b9802fe0 	ldrsw	x0, [sp, #44]
    40082798:	91010000 	add	x0, x0, #0x40
    4008279c:	d37ef400 	lsl	x0, x0, #2
    400827a0:	8b000020 	add	x0, x1, x0
    400827a4:	aa0003e1 	mov	x1, x0
    400827a8:	aa0203e0 	mov	x0, x2
    400827ac:	97fffef6 	bl	40082384 <writel>
    400827b0:	1400000e 	b	400827e8 <set_enable+0xc4>
    } else {
        writel(mask, (gicv2_dist_base() + GICD_ICENABLER + reg * sizeof(int)));
    400827b4:	b9802be2 	ldrsw	x2, [sp, #40]
    400827b8:	b0000060 	adrp	x0, 4008f000 <_gicv2>
    400827bc:	91000000 	add	x0, x0, #0x0
    400827c0:	f9400001 	ldr	x1, [x0]
    400827c4:	b9802fe0 	ldrsw	x0, [sp, #44]
    400827c8:	91018000 	add	x0, x0, #0x60
    400827cc:	d37ef400 	lsl	x0, x0, #2
    400827d0:	8b000020 	add	x0, x1, x0
    400827d4:	aa0003e1 	mov	x1, x0
    400827d8:	aa0203e0 	mov	x0, x2
    400827dc:	97fffeea 	bl	40082384 <writel>
    400827e0:	14000002 	b	400827e8 <set_enable+0xc4>
        return;
    400827e4:	d503201f 	nop
    }
    400827e8:	a8c37bfd 	ldp	x29, x30, [sp], #48
    400827ec:	d65f03c0 	ret

00000000400827f0 <uart_init>:

#include <io.h>

void uart_init() {
    400827f0:	d10083ff 	sub	sp, sp, #0x20
    // 禁用 UART
    UART0_CR = 0x0;
    400827f4:	d2800600 	mov	x0, #0x30                  	// #48
    400827f8:	f2a12000 	movk	x0, #0x900, lsl #16
    400827fc:	f900001f 	str	xzr, [x0]
    // 设置波特率，例如 115200
    // 波特率计算公式：
    // 整数部分 = UARTCLK / (16 * 波特率)
    // 小数部分 = 整数部分的小数部分 * 64 + 0.5
    // 假设 UARTCLK 为 24MHz
    uint32_t uartclk = 24000000;
    40082800:	d286c000 	mov	x0, #0x3600                	// #13824
    40082804:	f2a02dc0 	movk	x0, #0x16e, lsl #16
    40082808:	f9000fe0 	str	x0, [sp, #24]
    uint32_t baudrate = 115200;
    4008280c:	d2984000 	mov	x0, #0xc200                	// #49664
    40082810:	f2a00020 	movk	x0, #0x1, lsl #16
    40082814:	f9000be0 	str	x0, [sp, #16]
    uint32_t ibrd = uartclk / (16 * baudrate);
    40082818:	f9400be0 	ldr	x0, [sp, #16]
    4008281c:	d37cec00 	lsl	x0, x0, #4
    40082820:	f9400fe1 	ldr	x1, [sp, #24]
    40082824:	9ac00820 	udiv	x0, x1, x0
    40082828:	f90007e0 	str	x0, [sp, #8]
    uint32_t fbrd = (uartclk % (16 * baudrate)) * 4 / baudrate;
    4008282c:	f9400be0 	ldr	x0, [sp, #16]
    40082830:	d37cec01 	lsl	x1, x0, #4
    40082834:	f9400fe0 	ldr	x0, [sp, #24]
    40082838:	9ac10802 	udiv	x2, x0, x1
    4008283c:	9b017c41 	mul	x1, x2, x1
    40082840:	cb010000 	sub	x0, x0, x1
    40082844:	d37ef401 	lsl	x1, x0, #2
    40082848:	f9400be0 	ldr	x0, [sp, #16]
    4008284c:	9ac00820 	udiv	x0, x1, x0
    40082850:	f90003e0 	str	x0, [sp]

    UART0_IBRD = ibrd;
    40082854:	d2800480 	mov	x0, #0x24                  	// #36
    40082858:	f2a12000 	movk	x0, #0x900, lsl #16
    4008285c:	f94007e1 	ldr	x1, [sp, #8]
    40082860:	f9000001 	str	x1, [x0]
    UART0_FBRD = fbrd;
    40082864:	d2800500 	mov	x0, #0x28                  	// #40
    40082868:	f2a12000 	movk	x0, #0x900, lsl #16
    4008286c:	f94003e1 	ldr	x1, [sp]
    40082870:	f9000001 	str	x1, [x0]

    // 配置线路控制寄存器: 8 bits, no parity, one stop bit
    UART0_LCRH = (1 << 5) | (1 << 6);
    40082874:	d2800580 	mov	x0, #0x2c                  	// #44
    40082878:	f2a12000 	movk	x0, #0x900, lsl #16
    4008287c:	d2800c01 	mov	x1, #0x60                  	// #96
    40082880:	f9000001 	str	x1, [x0]

    // 启用 UART，TX 和 RX
    UART0_CR = (1 << 0) | (1 << 8) | (1 << 9);
    40082884:	d2800600 	mov	x0, #0x30                  	// #48
    40082888:	f2a12000 	movk	x0, #0x900, lsl #16
    4008288c:	d2806021 	mov	x1, #0x301                 	// #769
    40082890:	f9000001 	str	x1, [x0]
}
    40082894:	d503201f 	nop
    40082898:	910083ff 	add	sp, sp, #0x20
    4008289c:	d65f03c0 	ret

00000000400828a0 <uart_putc>:


void uart_putc(char c) {
    400828a0:	d10043ff 	sub	sp, sp, #0x10
    400828a4:	39003fe0 	strb	w0, [sp, #15]
    // 等待发送 FIFO 不为满
    while (UART0_FR & (1 << 5));
    400828a8:	d503201f 	nop
    400828ac:	d2800300 	mov	x0, #0x18                  	// #24
    400828b0:	f2a12000 	movk	x0, #0x900, lsl #16
    400828b4:	f9400000 	ldr	x0, [x0]
    400828b8:	927b0000 	and	x0, x0, #0x20
    400828bc:	f100001f 	cmp	x0, #0x0
    400828c0:	54ffff61 	b.ne	400828ac <uart_putc+0xc>  // b.any
    UART0_DR = c;
    400828c4:	d2a12000 	mov	x0, #0x9000000             	// #150994944
    400828c8:	39403fe1 	ldrb	w1, [sp, #15]
    400828cc:	f9000001 	str	x1, [x0]
}
    400828d0:	d503201f 	nop
    400828d4:	910043ff 	add	sp, sp, #0x10
    400828d8:	d65f03c0 	ret

00000000400828dc <uart_putstr>:

void uart_putstr(const char* str) {
    400828dc:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    400828e0:	910003fd 	mov	x29, sp
    400828e4:	f9000fe0 	str	x0, [sp, #24]
    while (*str) {
    400828e8:	14000006 	b	40082900 <uart_putstr+0x24>
        uart_putc(*str++);
    400828ec:	f9400fe0 	ldr	x0, [sp, #24]
    400828f0:	91000401 	add	x1, x0, #0x1
    400828f4:	f9000fe1 	str	x1, [sp, #24]
    400828f8:	39400000 	ldrb	w0, [x0]
    400828fc:	97ffffe9 	bl	400828a0 <uart_putc>
    while (*str) {
    40082900:	f9400fe0 	ldr	x0, [sp, #24]
    40082904:	39400000 	ldrb	w0, [x0]
    40082908:	7100001f 	cmp	w0, #0x0
    4008290c:	54ffff01 	b.ne	400828ec <uart_putstr+0x10>  // b.any
    }
}
    40082910:	d503201f 	nop
    40082914:	d503201f 	nop
    40082918:	a8c27bfd 	ldp	x29, x30, [sp], #32
    4008291c:	d65f03c0 	ret

0000000040082920 <uart_getc>:

char uart_getc() {
    // 等待接收 FIFO 不为空
    while (UART0_FR & (1 << 4));
    40082920:	d503201f 	nop
    40082924:	d2800300 	mov	x0, #0x18                  	// #24
    40082928:	f2a12000 	movk	x0, #0x900, lsl #16
    4008292c:	f9400000 	ldr	x0, [x0]
    40082930:	927c0000 	and	x0, x0, #0x10
    40082934:	f100001f 	cmp	x0, #0x0
    40082938:	54ffff61 	b.ne	40082924 <uart_getc+0x4>  // b.any
    return (char)UART0_DR;
    4008293c:	d2a12000 	mov	x0, #0x9000000             	// #150994944
    40082940:	f9400000 	ldr	x0, [x0]
    40082944:	12001c00 	and	w0, w0, #0xff
}
    40082948:	d65f03c0 	ret

000000004008294c <addchar>:
    int npad;
    bool alternate;
} strprops_t;

static void addchar(pstream_t *p, char c)
{
    4008294c:	d10043ff 	sub	sp, sp, #0x10
    40082950:	f90007e0 	str	x0, [sp, #8]
    40082954:	39001fe1 	strb	w1, [sp, #7]
    if (p->remain) {
    40082958:	f94007e0 	ldr	x0, [sp, #8]
    4008295c:	b9400800 	ldr	w0, [x0, #8]
    40082960:	7100001f 	cmp	w0, #0x0
    40082964:	540001a0 	b.eq	40082998 <addchar+0x4c>  // b.none
        *p->buffer++ = c;
    40082968:	f94007e0 	ldr	x0, [sp, #8]
    4008296c:	f9400000 	ldr	x0, [x0]
    40082970:	91000402 	add	x2, x0, #0x1
    40082974:	f94007e1 	ldr	x1, [sp, #8]
    40082978:	f9000022 	str	x2, [x1]
    4008297c:	39401fe1 	ldrb	w1, [sp, #7]
    40082980:	39000001 	strb	w1, [x0]
        --p->remain;
    40082984:	f94007e0 	ldr	x0, [sp, #8]
    40082988:	b9400800 	ldr	w0, [x0, #8]
    4008298c:	51000401 	sub	w1, w0, #0x1
    40082990:	f94007e0 	ldr	x0, [sp, #8]
    40082994:	b9000801 	str	w1, [x0, #8]
    }
    ++p->added;
    40082998:	f94007e0 	ldr	x0, [sp, #8]
    4008299c:	b9400c00 	ldr	w0, [x0, #12]
    400829a0:	11000401 	add	w1, w0, #0x1
    400829a4:	f94007e0 	ldr	x0, [sp, #8]
    400829a8:	b9000c01 	str	w1, [x0, #12]
}
    400829ac:	d503201f 	nop
    400829b0:	910043ff 	add	sp, sp, #0x10
    400829b4:	d65f03c0 	ret

00000000400829b8 <print_str>:

static void print_str(pstream_t *p, const char *s, strprops_t props)
{
    400829b8:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
    400829bc:	910003fd 	mov	x29, sp
    400829c0:	f9000bf3 	str	x19, [sp, #16]
    400829c4:	f9001fe0 	str	x0, [sp, #56]
    400829c8:	f9001be1 	str	x1, [sp, #48]
    400829cc:	aa0203e0 	mov	x0, x2
    400829d0:	aa0303e1 	mov	x1, x3
    400829d4:	f90013e0 	str	x0, [sp, #32]
    400829d8:	b9402be0 	ldr	w0, [sp, #40]
    400829dc:	33007c20 	bfxil	w0, w1, #0, #32
    400829e0:	b9002be0 	str	w0, [sp, #40]
    const char *s_orig = s;
    400829e4:	f9401be0 	ldr	x0, [sp, #48]
    400829e8:	f90023e0 	str	x0, [sp, #64]
    int npad = props.npad;
    400829ec:	b94027e0 	ldr	w0, [sp, #36]
    400829f0:	b9004fe0 	str	w0, [sp, #76]

    if (npad > 0) {
    400829f4:	b9404fe0 	ldr	w0, [sp, #76]
    400829f8:	7100001f 	cmp	w0, #0x0
    400829fc:	5400032d 	b.le	40082a60 <print_str+0xa8>
        npad -= strlen(s_orig);
    40082a00:	b9404ff3 	ldr	w19, [sp, #76]
    40082a04:	f94023e0 	ldr	x0, [sp, #64]
    40082a08:	94000471 	bl	40083bcc <strlen>
    40082a0c:	4b000260 	sub	w0, w19, w0
    40082a10:	b9004fe0 	str	w0, [sp, #76]
        while (npad > 0) {
    40082a14:	14000008 	b	40082a34 <print_str+0x7c>
            addchar(p, props.pad);
    40082a18:	394083e0 	ldrb	w0, [sp, #32]
    40082a1c:	2a0003e1 	mov	w1, w0
    40082a20:	f9401fe0 	ldr	x0, [sp, #56]
    40082a24:	97ffffca 	bl	4008294c <addchar>
            --npad;
    40082a28:	b9404fe0 	ldr	w0, [sp, #76]
    40082a2c:	51000400 	sub	w0, w0, #0x1
    40082a30:	b9004fe0 	str	w0, [sp, #76]
        while (npad > 0) {
    40082a34:	b9404fe0 	ldr	w0, [sp, #76]
    40082a38:	7100001f 	cmp	w0, #0x0
    40082a3c:	54fffeec 	b.gt	40082a18 <print_str+0x60>
        }
    }

    while (*s)
    40082a40:	14000008 	b	40082a60 <print_str+0xa8>
	addchar(p, *s++);
    40082a44:	f9401be0 	ldr	x0, [sp, #48]
    40082a48:	91000401 	add	x1, x0, #0x1
    40082a4c:	f9001be1 	str	x1, [sp, #48]
    40082a50:	39400000 	ldrb	w0, [x0]
    40082a54:	2a0003e1 	mov	w1, w0
    40082a58:	f9401fe0 	ldr	x0, [sp, #56]
    40082a5c:	97ffffbc 	bl	4008294c <addchar>
    while (*s)
    40082a60:	f9401be0 	ldr	x0, [sp, #48]
    40082a64:	39400000 	ldrb	w0, [x0]
    40082a68:	7100001f 	cmp	w0, #0x0
    40082a6c:	54fffec1 	b.ne	40082a44 <print_str+0x8c>  // b.any

    if (npad < 0) {
    40082a70:	b9404fe0 	ldr	w0, [sp, #76]
    40082a74:	7100001f 	cmp	w0, #0x0
    40082a78:	5400028a 	b.ge	40082ac8 <print_str+0x110>  // b.tcont
        props.pad = ' '; /* ignore '0' flag with '-' flag */
    40082a7c:	52800400 	mov	w0, #0x20                  	// #32
    40082a80:	390083e0 	strb	w0, [sp, #32]
        npad += strlen(s_orig);
    40082a84:	f94023e0 	ldr	x0, [sp, #64]
    40082a88:	94000451 	bl	40083bcc <strlen>
    40082a8c:	2a0003e1 	mov	w1, w0
    40082a90:	b9404fe0 	ldr	w0, [sp, #76]
    40082a94:	0b000020 	add	w0, w1, w0
    40082a98:	b9004fe0 	str	w0, [sp, #76]
        while (npad < 0) {
    40082a9c:	14000008 	b	40082abc <print_str+0x104>
            addchar(p, props.pad);
    40082aa0:	394083e0 	ldrb	w0, [sp, #32]
    40082aa4:	2a0003e1 	mov	w1, w0
    40082aa8:	f9401fe0 	ldr	x0, [sp, #56]
    40082aac:	97ffffa8 	bl	4008294c <addchar>
            ++npad;
    40082ab0:	b9404fe0 	ldr	w0, [sp, #76]
    40082ab4:	11000400 	add	w0, w0, #0x1
    40082ab8:	b9004fe0 	str	w0, [sp, #76]
        while (npad < 0) {
    40082abc:	b9404fe0 	ldr	w0, [sp, #76]
    40082ac0:	7100001f 	cmp	w0, #0x0
    40082ac4:	54fffeeb 	b.lt	40082aa0 <print_str+0xe8>  // b.tstop
        }
    }
}
    40082ac8:	d503201f 	nop
    40082acc:	f9400bf3 	ldr	x19, [sp, #16]
    40082ad0:	a8c57bfd 	ldp	x29, x30, [sp], #80
    40082ad4:	d65f03c0 	ret

0000000040082ad8 <print_int>:

static void print_int(pstream_t *ps, long n, int base, strprops_t props){
    40082ad8:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40082adc:	910003fd 	mov	x29, sp
    40082ae0:	f9001fe0 	str	x0, [sp, #56]
    40082ae4:	f9001be1 	str	x1, [sp, #48]
    40082ae8:	b9002fe2 	str	w2, [sp, #44]
    40082aec:	aa0303e0 	mov	x0, x3
    40082af0:	aa0403e1 	mov	x1, x4
    40082af4:	f801c3e0 	stur	x0, [sp, #28]
    40082af8:	b94027e0 	ldr	w0, [sp, #36]
    40082afc:	33007c20 	bfxil	w0, w1, #0, #32
    40082b00:	b90027e0 	str	w0, [sp, #36]

    char buf[sizeof(long) * 3 + 2], *p = buf;
    40082b04:	910103e0 	add	x0, sp, #0x40
    40082b08:	f90037e0 	str	x0, [sp, #104]
    int s = 0, i;
    40082b0c:	b90067ff 	str	wzr, [sp, #100]

    if (n < 0) {
    40082b10:	f9401be0 	ldr	x0, [sp, #48]
    40082b14:	f100001f 	cmp	x0, #0x0
    40082b18:	540002ea 	b.ge	40082b74 <print_int+0x9c>  // b.tcont
        n = -n;
    40082b1c:	f9401be0 	ldr	x0, [sp, #48]
    40082b20:	cb0003e0 	neg	x0, x0
    40082b24:	f9001be0 	str	x0, [sp, #48]
        s = 1;
    40082b28:	52800020 	mov	w0, #0x1                   	// #1
    40082b2c:	b90067e0 	str	w0, [sp, #100]
    }

    while (n) {
    40082b30:	14000011 	b	40082b74 <print_int+0x9c>
        *p++ = digits[n % base];
    40082b34:	b9802fe1 	ldrsw	x1, [sp, #44]
    40082b38:	f9401be0 	ldr	x0, [sp, #48]
    40082b3c:	9ac10c02 	sdiv	x2, x0, x1
    40082b40:	9b017c41 	mul	x1, x2, x1
    40082b44:	cb010001 	sub	x1, x0, x1
    40082b48:	f94037e0 	ldr	x0, [sp, #104]
    40082b4c:	91000402 	add	x2, x0, #0x1
    40082b50:	f90037e2 	str	x2, [sp, #104]
    40082b54:	f0000002 	adrp	x2, 40085000 <digits>
    40082b58:	91000042 	add	x2, x2, #0x0
    40082b5c:	38616841 	ldrb	w1, [x2, x1]
    40082b60:	39000001 	strb	w1, [x0]
        n /= base;
    40082b64:	b9802fe0 	ldrsw	x0, [sp, #44]
    40082b68:	f9401be1 	ldr	x1, [sp, #48]
    40082b6c:	9ac00c20 	sdiv	x0, x1, x0
    40082b70:	f9001be0 	str	x0, [sp, #48]
    while (n) {
    40082b74:	f9401be0 	ldr	x0, [sp, #48]
    40082b78:	f100001f 	cmp	x0, #0x0
    40082b7c:	54fffdc1 	b.ne	40082b34 <print_int+0x5c>  // b.any
    }

    if (s)
    40082b80:	b94067e0 	ldr	w0, [sp, #100]
    40082b84:	7100001f 	cmp	w0, #0x0
    40082b88:	540000c0 	b.eq	40082ba0 <print_int+0xc8>  // b.none
	*p++ = '-';
    40082b8c:	f94037e0 	ldr	x0, [sp, #104]
    40082b90:	91000401 	add	x1, x0, #0x1
    40082b94:	f90037e1 	str	x1, [sp, #104]
    40082b98:	528005a1 	mov	w1, #0x2d                  	// #45
    40082b9c:	39000001 	strb	w1, [x0]

    if (p == buf)
    40082ba0:	910103e0 	add	x0, sp, #0x40
    40082ba4:	f94037e1 	ldr	x1, [sp, #104]
    40082ba8:	eb00003f 	cmp	x1, x0
    40082bac:	540000c1 	b.ne	40082bc4 <print_int+0xec>  // b.any
	*p++ = '0';
    40082bb0:	f94037e0 	ldr	x0, [sp, #104]
    40082bb4:	91000401 	add	x1, x0, #0x1
    40082bb8:	f90037e1 	str	x1, [sp, #104]
    40082bbc:	52800601 	mov	w1, #0x30                  	// #48
    40082bc0:	39000001 	strb	w1, [x0]

    for (i = 0; i < (p - buf) / 2; ++i) {
    40082bc4:	b90063ff 	str	wzr, [sp, #96]
    40082bc8:	14000018 	b	40082c28 <print_int+0x150>
        char tmp;

        tmp = buf[i];
    40082bcc:	b98063e0 	ldrsw	x0, [sp, #96]
    40082bd0:	910103e1 	add	x1, sp, #0x40
    40082bd4:	38606820 	ldrb	w0, [x1, x0]
    40082bd8:	39017fe0 	strb	w0, [sp, #95]
        buf[i] = p[-1-i];
    40082bdc:	b94063e0 	ldr	w0, [sp, #96]
    40082be0:	2a2003e0 	mvn	w0, w0
    40082be4:	93407c00 	sxtw	x0, w0
    40082be8:	f94037e1 	ldr	x1, [sp, #104]
    40082bec:	8b000020 	add	x0, x1, x0
    40082bf0:	39400002 	ldrb	w2, [x0]
    40082bf4:	b98063e0 	ldrsw	x0, [sp, #96]
    40082bf8:	910103e1 	add	x1, sp, #0x40
    40082bfc:	38206822 	strb	w2, [x1, x0]
        p[-1-i] = tmp;
    40082c00:	b94063e0 	ldr	w0, [sp, #96]
    40082c04:	2a2003e0 	mvn	w0, w0
    40082c08:	93407c00 	sxtw	x0, w0
    40082c0c:	f94037e1 	ldr	x1, [sp, #104]
    40082c10:	8b000020 	add	x0, x1, x0
    40082c14:	39417fe1 	ldrb	w1, [sp, #95]
    40082c18:	39000001 	strb	w1, [x0]
    for (i = 0; i < (p - buf) / 2; ++i) {
    40082c1c:	b94063e0 	ldr	w0, [sp, #96]
    40082c20:	11000400 	add	w0, w0, #0x1
    40082c24:	b90063e0 	str	w0, [sp, #96]
    40082c28:	b98063e1 	ldrsw	x1, [sp, #96]
    40082c2c:	910103e0 	add	x0, sp, #0x40
    40082c30:	f94037e2 	ldr	x2, [sp, #104]
    40082c34:	cb000040 	sub	x0, x2, x0
    40082c38:	d37ffc02 	lsr	x2, x0, #63
    40082c3c:	8b000040 	add	x0, x2, x0
    40082c40:	9341fc00 	asr	x0, x0, #1
    40082c44:	eb00003f 	cmp	x1, x0
    40082c48:	54fffc2b 	b.lt	40082bcc <print_int+0xf4>  // b.tstop
    }

    *p = 0;
    40082c4c:	f94037e0 	ldr	x0, [sp, #104]
    40082c50:	3900001f 	strb	wzr, [x0]

    print_str(ps, buf, props);
    40082c54:	f841c3e2 	ldur	x2, [sp, #28]
    40082c58:	b94027e1 	ldr	w1, [sp, #36]
    40082c5c:	910103e0 	add	x0, sp, #0x40
    40082c60:	aa0103e3 	mov	x3, x1
    40082c64:	aa0003e1 	mov	x1, x0
    40082c68:	f9401fe0 	ldr	x0, [sp, #56]
    40082c6c:	97ffff53 	bl	400829b8 <print_str>
}
    40082c70:	d503201f 	nop
    40082c74:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40082c78:	d65f03c0 	ret

0000000040082c7c <print_unsigned>:

static void print_unsigned(pstream_t *ps, uint32_t n, int base,
			   strprops_t props)
{
    40082c7c:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40082c80:	910003fd 	mov	x29, sp
    40082c84:	f9001fe0 	str	x0, [sp, #56]
    40082c88:	f9001be1 	str	x1, [sp, #48]
    40082c8c:	b9002fe2 	str	w2, [sp, #44]
    40082c90:	aa0303e0 	mov	x0, x3
    40082c94:	aa0403e1 	mov	x1, x4
    40082c98:	f801c3e0 	stur	x0, [sp, #28]
    40082c9c:	b94027e0 	ldr	w0, [sp, #36]
    40082ca0:	33007c20 	bfxil	w0, w1, #0, #32
    40082ca4:	b90027e0 	str	w0, [sp, #36]
    char buf[sizeof(long) * 3 + 3], *p = buf;
    40082ca8:	910123e0 	add	x0, sp, #0x48
    40082cac:	f90037e0 	str	x0, [sp, #104]
    int i;

    while (n) {
    40082cb0:	14000011 	b	40082cf4 <print_unsigned+0x78>
	*p++ = digits[n % base];
    40082cb4:	b9802fe1 	ldrsw	x1, [sp, #44]
    40082cb8:	f9401be0 	ldr	x0, [sp, #48]
    40082cbc:	9ac10802 	udiv	x2, x0, x1
    40082cc0:	9b017c41 	mul	x1, x2, x1
    40082cc4:	cb010001 	sub	x1, x0, x1
    40082cc8:	f94037e0 	ldr	x0, [sp, #104]
    40082ccc:	91000402 	add	x2, x0, #0x1
    40082cd0:	f90037e2 	str	x2, [sp, #104]
    40082cd4:	f0000002 	adrp	x2, 40085000 <digits>
    40082cd8:	91000042 	add	x2, x2, #0x0
    40082cdc:	38616841 	ldrb	w1, [x2, x1]
    40082ce0:	39000001 	strb	w1, [x0]
	n /= base;
    40082ce4:	b9802fe0 	ldrsw	x0, [sp, #44]
    40082ce8:	f9401be1 	ldr	x1, [sp, #48]
    40082cec:	9ac00820 	udiv	x0, x1, x0
    40082cf0:	f9001be0 	str	x0, [sp, #48]
    while (n) {
    40082cf4:	f9401be0 	ldr	x0, [sp, #48]
    40082cf8:	f100001f 	cmp	x0, #0x0
    40082cfc:	54fffdc1 	b.ne	40082cb4 <print_unsigned+0x38>  // b.any
    }

    if (p == buf)
    40082d00:	910123e0 	add	x0, sp, #0x48
    40082d04:	f94037e1 	ldr	x1, [sp, #104]
    40082d08:	eb00003f 	cmp	x1, x0
    40082d0c:	540000e1 	b.ne	40082d28 <print_unsigned+0xac>  // b.any
	*p++ = '0';
    40082d10:	f94037e0 	ldr	x0, [sp, #104]
    40082d14:	91000401 	add	x1, x0, #0x1
    40082d18:	f90037e1 	str	x1, [sp, #104]
    40082d1c:	52800601 	mov	w1, #0x30                  	// #48
    40082d20:	39000001 	strb	w1, [x0]
    40082d24:	14000024 	b	40082db4 <print_unsigned+0x138>
    else if (props.alternate && base == 16) {
    40082d28:	394093e0 	ldrb	w0, [sp, #36]
    40082d2c:	7100001f 	cmp	w0, #0x0
    40082d30:	54000420 	b.eq	40082db4 <print_unsigned+0x138>  // b.none
    40082d34:	b9402fe0 	ldr	w0, [sp, #44]
    40082d38:	7100401f 	cmp	w0, #0x10
    40082d3c:	540003c1 	b.ne	40082db4 <print_unsigned+0x138>  // b.any
	if (props.pad == '0') {
    40082d40:	394073e0 	ldrb	w0, [sp, #28]
    40082d44:	7100c01f 	cmp	w0, #0x30
    40082d48:	54000221 	b.ne	40082d8c <print_unsigned+0x110>  // b.any
	    addchar(ps, '0');
    40082d4c:	52800601 	mov	w1, #0x30                  	// #48
    40082d50:	f9401fe0 	ldr	x0, [sp, #56]
    40082d54:	97fffefe 	bl	4008294c <addchar>
	    addchar(ps, 'x');
    40082d58:	52800f01 	mov	w1, #0x78                  	// #120
    40082d5c:	f9401fe0 	ldr	x0, [sp, #56]
    40082d60:	97fffefb 	bl	4008294c <addchar>

	    if (props.npad > 0)
    40082d64:	b94023e0 	ldr	w0, [sp, #32]
    40082d68:	7100001f 	cmp	w0, #0x0
    40082d6c:	5400024d 	b.le	40082db4 <print_unsigned+0x138>
		props.npad = MAX(props.npad - 2, 0);
    40082d70:	b94023e0 	ldr	w0, [sp, #32]
    40082d74:	52800041 	mov	w1, #0x2                   	// #2
    40082d78:	7100081f 	cmp	w0, #0x2
    40082d7c:	1a81a000 	csel	w0, w0, w1, ge  // ge = tcont
    40082d80:	51000800 	sub	w0, w0, #0x2
    40082d84:	b90023e0 	str	w0, [sp, #32]
    40082d88:	1400000b 	b	40082db4 <print_unsigned+0x138>
	} else {
	    *p++ = 'x';
    40082d8c:	f94037e0 	ldr	x0, [sp, #104]
    40082d90:	91000401 	add	x1, x0, #0x1
    40082d94:	f90037e1 	str	x1, [sp, #104]
    40082d98:	52800f01 	mov	w1, #0x78                  	// #120
    40082d9c:	39000001 	strb	w1, [x0]
	    *p++ = '0';
    40082da0:	f94037e0 	ldr	x0, [sp, #104]
    40082da4:	91000401 	add	x1, x0, #0x1
    40082da8:	f90037e1 	str	x1, [sp, #104]
    40082dac:	52800601 	mov	w1, #0x30                  	// #48
    40082db0:	39000001 	strb	w1, [x0]
	}
    }

    for (i = 0; i < (p - buf) / 2; ++i) {
    40082db4:	b90067ff 	str	wzr, [sp, #100]
    40082db8:	14000018 	b	40082e18 <print_unsigned+0x19c>
	char tmp;

	tmp = buf[i];
    40082dbc:	b98067e0 	ldrsw	x0, [sp, #100]
    40082dc0:	910123e1 	add	x1, sp, #0x48
    40082dc4:	38606820 	ldrb	w0, [x1, x0]
    40082dc8:	39018fe0 	strb	w0, [sp, #99]
	buf[i] = p[-1-i];
    40082dcc:	b94067e0 	ldr	w0, [sp, #100]
    40082dd0:	2a2003e0 	mvn	w0, w0
    40082dd4:	93407c00 	sxtw	x0, w0
    40082dd8:	f94037e1 	ldr	x1, [sp, #104]
    40082ddc:	8b000020 	add	x0, x1, x0
    40082de0:	39400002 	ldrb	w2, [x0]
    40082de4:	b98067e0 	ldrsw	x0, [sp, #100]
    40082de8:	910123e1 	add	x1, sp, #0x48
    40082dec:	38206822 	strb	w2, [x1, x0]
	p[-1-i] = tmp;
    40082df0:	b94067e0 	ldr	w0, [sp, #100]
    40082df4:	2a2003e0 	mvn	w0, w0
    40082df8:	93407c00 	sxtw	x0, w0
    40082dfc:	f94037e1 	ldr	x1, [sp, #104]
    40082e00:	8b000020 	add	x0, x1, x0
    40082e04:	39418fe1 	ldrb	w1, [sp, #99]
    40082e08:	39000001 	strb	w1, [x0]
    for (i = 0; i < (p - buf) / 2; ++i) {
    40082e0c:	b94067e0 	ldr	w0, [sp, #100]
    40082e10:	11000400 	add	w0, w0, #0x1
    40082e14:	b90067e0 	str	w0, [sp, #100]
    40082e18:	b98067e1 	ldrsw	x1, [sp, #100]
    40082e1c:	910123e0 	add	x0, sp, #0x48
    40082e20:	f94037e2 	ldr	x2, [sp, #104]
    40082e24:	cb000040 	sub	x0, x2, x0
    40082e28:	d37ffc02 	lsr	x2, x0, #63
    40082e2c:	8b000040 	add	x0, x2, x0
    40082e30:	9341fc00 	asr	x0, x0, #1
    40082e34:	eb00003f 	cmp	x1, x0
    40082e38:	54fffc2b 	b.lt	40082dbc <print_unsigned+0x140>  // b.tstop
    }

    *p = 0;
    40082e3c:	f94037e0 	ldr	x0, [sp, #104]
    40082e40:	3900001f 	strb	wzr, [x0]

    print_str(ps, buf, props);
    40082e44:	f841c3e2 	ldur	x2, [sp, #28]
    40082e48:	b94027e1 	ldr	w1, [sp, #36]
    40082e4c:	910123e0 	add	x0, sp, #0x48
    40082e50:	aa0103e3 	mov	x3, x1
    40082e54:	aa0003e1 	mov	x1, x0
    40082e58:	f9401fe0 	ldr	x0, [sp, #56]
    40082e5c:	97fffed7 	bl	400829b8 <print_str>
}
    40082e60:	d503201f 	nop
    40082e64:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40082e68:	d65f03c0 	ret

0000000040082e6c <fmtnum>:

static int fmtnum(const char **fmt)
{
    40082e6c:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40082e70:	910003fd 	mov	x29, sp
    40082e74:	f9000fe0 	str	x0, [sp, #24]
    const char *f = *fmt;
    40082e78:	f9400fe0 	ldr	x0, [sp, #24]
    40082e7c:	f9400000 	ldr	x0, [x0]
    40082e80:	f90017e0 	str	x0, [sp, #40]
    int len = 0, num;
    40082e84:	b90027ff 	str	wzr, [sp, #36]

    if (*f == '-')
    40082e88:	f94017e0 	ldr	x0, [sp, #40]
    40082e8c:	39400000 	ldrb	w0, [x0]
    40082e90:	7100b41f 	cmp	w0, #0x2d
    40082e94:	540001c1 	b.ne	40082ecc <fmtnum+0x60>  // b.any
	++f, ++len;
    40082e98:	f94017e0 	ldr	x0, [sp, #40]
    40082e9c:	91000400 	add	x0, x0, #0x1
    40082ea0:	f90017e0 	str	x0, [sp, #40]
    40082ea4:	b94027e0 	ldr	w0, [sp, #36]
    40082ea8:	11000400 	add	w0, w0, #0x1
    40082eac:	b90027e0 	str	w0, [sp, #36]

    while (*f >= '0' && *f <= '9')
    40082eb0:	14000007 	b	40082ecc <fmtnum+0x60>
	++f, ++len;
    40082eb4:	f94017e0 	ldr	x0, [sp, #40]
    40082eb8:	91000400 	add	x0, x0, #0x1
    40082ebc:	f90017e0 	str	x0, [sp, #40]
    40082ec0:	b94027e0 	ldr	w0, [sp, #36]
    40082ec4:	11000400 	add	w0, w0, #0x1
    40082ec8:	b90027e0 	str	w0, [sp, #36]
    while (*f >= '0' && *f <= '9')
    40082ecc:	f94017e0 	ldr	x0, [sp, #40]
    40082ed0:	39400000 	ldrb	w0, [x0]
    40082ed4:	7100bc1f 	cmp	w0, #0x2f
    40082ed8:	540000a9 	b.ls	40082eec <fmtnum+0x80>  // b.plast
    40082edc:	f94017e0 	ldr	x0, [sp, #40]
    40082ee0:	39400000 	ldrb	w0, [x0]
    40082ee4:	7100e41f 	cmp	w0, #0x39
    40082ee8:	54fffe69 	b.ls	40082eb4 <fmtnum+0x48>  // b.plast

    num = atol(*fmt);
    40082eec:	f9400fe0 	ldr	x0, [sp, #24]
    40082ef0:	f9400000 	ldr	x0, [x0]
    40082ef4:	9400047e 	bl	400840ec <atol>
    40082ef8:	b90023e0 	str	w0, [sp, #32]
    *fmt += len;
    40082efc:	f9400fe0 	ldr	x0, [sp, #24]
    40082f00:	f9400001 	ldr	x1, [x0]
    40082f04:	b98027e0 	ldrsw	x0, [sp, #36]
    40082f08:	8b000021 	add	x1, x1, x0
    40082f0c:	f9400fe0 	ldr	x0, [sp, #24]
    40082f10:	f9000001 	str	x1, [x0]
    return num;
    40082f14:	b94023e0 	ldr	w0, [sp, #32]
}
    40082f18:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40082f1c:	d65f03c0 	ret

0000000040082f20 <vsnprintf>:

int vsnprintf(char *buf, int size, const char *fmt, va_list va)
{
    40082f20:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40082f24:	910003fd 	mov	x29, sp
    40082f28:	f9000bf3 	str	x19, [sp, #16]
    40082f2c:	f9001fe0 	str	x0, [sp, #56]
    40082f30:	b90037e1 	str	w1, [sp, #52]
    40082f34:	f90017e2 	str	x2, [sp, #40]
    40082f38:	aa0303f3 	mov	x19, x3
    pstream_t s;

    s.buffer = buf;
    40082f3c:	f9401fe0 	ldr	x0, [sp, #56]
    40082f40:	f9002fe0 	str	x0, [sp, #88]
    s.remain = size - 1;
    40082f44:	b94037e0 	ldr	w0, [sp, #52]
    40082f48:	51000400 	sub	w0, w0, #0x1
    40082f4c:	b90063e0 	str	w0, [sp, #96]
    s.added = 0;
    40082f50:	b90067ff 	str	wzr, [sp, #100]
    while (*fmt) {
    40082f54:	140001e1 	b	400836d8 <vsnprintf+0x7b8>
	char f = *fmt++;
    40082f58:	f94017e0 	ldr	x0, [sp, #40]
    40082f5c:	91000401 	add	x1, x0, #0x1
    40082f60:	f90017e1 	str	x1, [sp, #40]
    40082f64:	39400000 	ldrb	w0, [x0]
    40082f68:	3901afe0 	strb	w0, [sp, #107]
	int nlong = 0;
    40082f6c:	b9006fff 	str	wzr, [sp, #108]
	strprops_t props;
	memset(&props, 0, sizeof(props));
    40082f70:	910123e0 	add	x0, sp, #0x48
    40082f74:	d2800182 	mov	x2, #0xc                   	// #12
    40082f78:	52800001 	mov	w1, #0x0                   	// #0
    40082f7c:	940003b3 	bl	40083e48 <memset>
	props.pad = ' ';
    40082f80:	52800400 	mov	w0, #0x20                  	// #32
    40082f84:	390123e0 	strb	w0, [sp, #72]

	if (f != '%') {
    40082f88:	3941afe0 	ldrb	w0, [sp, #107]
    40082f8c:	7100941f 	cmp	w0, #0x25
    40082f90:	540000a0 	b.eq	40082fa4 <vsnprintf+0x84>  // b.none
	    addchar(&s, f);
    40082f94:	910163e0 	add	x0, sp, #0x58
    40082f98:	3941afe1 	ldrb	w1, [sp, #107]
    40082f9c:	97fffe6c 	bl	4008294c <addchar>
    40082fa0:	140001ce 	b	400836d8 <vsnprintf+0x7b8>
	    continue;
	}
    morefmt:
    40082fa4:	d503201f 	nop
	f = *fmt++;
    40082fa8:	f94017e0 	ldr	x0, [sp, #40]
    40082fac:	91000401 	add	x1, x0, #0x1
    40082fb0:	f90017e1 	str	x1, [sp, #40]
    40082fb4:	39400000 	ldrb	w0, [x0]
    40082fb8:	3901afe0 	strb	w0, [sp, #107]
	switch (f) {
    40082fbc:	3941afe0 	ldrb	w0, [sp, #107]
    40082fc0:	7101e81f 	cmp	w0, #0x7a
    40082fc4:	54000d80 	b.eq	40083174 <vsnprintf+0x254>  // b.none
    40082fc8:	7101e81f 	cmp	w0, #0x7a
    40082fcc:	540037ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40082fd0:	7101e01f 	cmp	w0, #0x78
    40082fd4:	540024a0 	b.eq	40083468 <vsnprintf+0x548>  // b.none
    40082fd8:	7101e01f 	cmp	w0, #0x78
    40082fdc:	5400376c 	b.gt	400836c8 <vsnprintf+0x7a8>
    40082fe0:	7101d41f 	cmp	w0, #0x75
    40082fe4:	54001880 	b.eq	400832f4 <vsnprintf+0x3d4>  // b.none
    40082fe8:	7101d41f 	cmp	w0, #0x75
    40082fec:	540036ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40082ff0:	7101d01f 	cmp	w0, #0x74
    40082ff4:	54000c00 	b.eq	40083174 <vsnprintf+0x254>  // b.none
    40082ff8:	7101d01f 	cmp	w0, #0x74
    40082ffc:	5400366c 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083000:	7101cc1f 	cmp	w0, #0x73
    40083004:	540032e0 	b.eq	40083660 <vsnprintf+0x740>  // b.none
    40083008:	7101cc1f 	cmp	w0, #0x73
    4008300c:	540035ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083010:	7101c01f 	cmp	w0, #0x70
    40083014:	54002e40 	b.eq	400835dc <vsnprintf+0x6bc>  // b.none
    40083018:	7101c01f 	cmp	w0, #0x70
    4008301c:	5400356c 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083020:	7101b01f 	cmp	w0, #0x6c
    40083024:	54000a00 	b.eq	40083164 <vsnprintf+0x244>  // b.none
    40083028:	7101b01f 	cmp	w0, #0x6c
    4008302c:	540034ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083030:	7101901f 	cmp	w0, #0x64
    40083034:	54000a60 	b.eq	40083180 <vsnprintf+0x260>  // b.none
    40083038:	7101901f 	cmp	w0, #0x64
    4008303c:	5400346c 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083040:	71018c1f 	cmp	w0, #0x63
    40083044:	54000380 	b.eq	400830b4 <vsnprintf+0x194>  // b.none
    40083048:	71018c1f 	cmp	w0, #0x63
    4008304c:	540033ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083050:	7100e41f 	cmp	w0, #0x39
    40083054:	540033ac 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083058:	7100c41f 	cmp	w0, #0x31
    4008305c:	5400076a 	b.ge	40083148 <vsnprintf+0x228>  // b.tcont
    40083060:	7100c01f 	cmp	w0, #0x30
    40083064:	54000680 	b.eq	40083134 <vsnprintf+0x214>  // b.none
    40083068:	7100c01f 	cmp	w0, #0x30
    4008306c:	540032ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083070:	7100b41f 	cmp	w0, #0x2d
    40083074:	540006a0 	b.eq	40083148 <vsnprintf+0x228>  // b.none
    40083078:	7100b41f 	cmp	w0, #0x2d
    4008307c:	5400326c 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083080:	7100941f 	cmp	w0, #0x25
    40083084:	54000100 	b.eq	400830a4 <vsnprintf+0x184>  // b.none
    40083088:	7100941f 	cmp	w0, #0x25
    4008308c:	540031ec 	b.gt	400836c8 <vsnprintf+0x7a8>
    40083090:	7100001f 	cmp	w0, #0x0
    40083094:	54000420 	b.eq	40083118 <vsnprintf+0x1f8>  // b.none
    40083098:	71008c1f 	cmp	w0, #0x23
    4008309c:	54000460 	b.eq	40083128 <vsnprintf+0x208>  // b.none
    400830a0:	1400018a 	b	400836c8 <vsnprintf+0x7a8>
	case '%':
	    addchar(&s, '%');
    400830a4:	910163e0 	add	x0, sp, #0x58
    400830a8:	528004a1 	mov	w1, #0x25                  	// #37
    400830ac:	97fffe28 	bl	4008294c <addchar>
	    break;
    400830b0:	1400018a 	b	400836d8 <vsnprintf+0x7b8>
	case 'c':
            addchar(&s, va_arg(va, int));
    400830b4:	b9401a61 	ldr	w1, [x19, #24]
    400830b8:	f9400260 	ldr	x0, [x19]
    400830bc:	7100003f 	cmp	w1, #0x0
    400830c0:	540000ab 	b.lt	400830d4 <vsnprintf+0x1b4>  // b.tstop
    400830c4:	91002c01 	add	x1, x0, #0xb
    400830c8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400830cc:	f9000261 	str	x1, [x19]
    400830d0:	1400000d 	b	40083104 <vsnprintf+0x1e4>
    400830d4:	11002022 	add	w2, w1, #0x8
    400830d8:	b9001a62 	str	w2, [x19, #24]
    400830dc:	b9401a62 	ldr	w2, [x19, #24]
    400830e0:	7100005f 	cmp	w2, #0x0
    400830e4:	540000ad 	b.le	400830f8 <vsnprintf+0x1d8>
    400830e8:	91002c01 	add	x1, x0, #0xb
    400830ec:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400830f0:	f9000261 	str	x1, [x19]
    400830f4:	14000004 	b	40083104 <vsnprintf+0x1e4>
    400830f8:	f9400662 	ldr	x2, [x19, #8]
    400830fc:	93407c20 	sxtw	x0, w1
    40083100:	8b000040 	add	x0, x2, x0
    40083104:	b9400000 	ldr	w0, [x0]
    40083108:	12001c01 	and	w1, w0, #0xff
    4008310c:	910163e0 	add	x0, sp, #0x58
    40083110:	97fffe0f 	bl	4008294c <addchar>
	    break;
    40083114:	14000171 	b	400836d8 <vsnprintf+0x7b8>
	case '\0':
	    --fmt;
    40083118:	f94017e0 	ldr	x0, [sp, #40]
    4008311c:	d1000400 	sub	x0, x0, #0x1
    40083120:	f90017e0 	str	x0, [sp, #40]
	    break;
    40083124:	1400016d 	b	400836d8 <vsnprintf+0x7b8>
	case '#':
	    props.alternate = true;
    40083128:	52800020 	mov	w0, #0x1                   	// #1
    4008312c:	390143e0 	strb	w0, [sp, #80]
	    goto morefmt;
    40083130:	17ffff9e 	b	40082fa8 <vsnprintf+0x88>
	case '0':
	    props.pad = '0';
    40083134:	52800600 	mov	w0, #0x30                  	// #48
    40083138:	390123e0 	strb	w0, [sp, #72]
	    ++fmt;
    4008313c:	f94017e0 	ldr	x0, [sp, #40]
    40083140:	91000400 	add	x0, x0, #0x1
    40083144:	f90017e0 	str	x0, [sp, #40]
	    /* fall through */
	case '1'...'9':
	case '-':
	    --fmt;
    40083148:	f94017e0 	ldr	x0, [sp, #40]
    4008314c:	d1000400 	sub	x0, x0, #0x1
    40083150:	f90017e0 	str	x0, [sp, #40]
	    props.npad = fmtnum(&fmt);
    40083154:	9100a3e0 	add	x0, sp, #0x28
    40083158:	97ffff45 	bl	40082e6c <fmtnum>
    4008315c:	b9004fe0 	str	w0, [sp, #76]
	    goto morefmt;
    40083160:	17ffff92 	b	40082fa8 <vsnprintf+0x88>
	case 'l':
	    ++nlong;
    40083164:	b9406fe0 	ldr	w0, [sp, #108]
    40083168:	11000400 	add	w0, w0, #0x1
    4008316c:	b9006fe0 	str	w0, [sp, #108]
	    goto morefmt;
    40083170:	17ffff8e 	b	40082fa8 <vsnprintf+0x88>
	    /* Here we only care that sizeof(size_t) == sizeof(long).
	     * On a 32-bit platform it doesn't matter that size_t is
	     * typedef'ed to int or long; va_arg will work either way.
	     * Same for ptrdiff_t (%td).
	     */
	    nlong = 1;
    40083174:	52800020 	mov	w0, #0x1                   	// #1
    40083178:	b9006fe0 	str	w0, [sp, #108]
	    goto morefmt;
    4008317c:	17ffff8b 	b	40082fa8 <vsnprintf+0x88>
    40083180:	b9406fe0 	ldr	w0, [sp, #108]
    40083184:	7100001f 	cmp	w0, #0x0
    40083188:	540000a0 	b.eq	4008319c <vsnprintf+0x27c>  // b.none
    4008318c:	b9406fe0 	ldr	w0, [sp, #108]
    40083190:	7100041f 	cmp	w0, #0x1
    40083194:	540003e0 	b.eq	40083210 <vsnprintf+0x2f0>  // b.none
    40083198:	1400003a 	b	40083280 <vsnprintf+0x360>
	case 'd':
	    switch (nlong) {
	    case 0:
		print_int(&s, va_arg(va, int), 10, props);
    4008319c:	b9401a61 	ldr	w1, [x19, #24]
    400831a0:	f9400260 	ldr	x0, [x19]
    400831a4:	7100003f 	cmp	w1, #0x0
    400831a8:	540000ab 	b.lt	400831bc <vsnprintf+0x29c>  // b.tstop
    400831ac:	91002c01 	add	x1, x0, #0xb
    400831b0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400831b4:	f9000261 	str	x1, [x19]
    400831b8:	1400000d 	b	400831ec <vsnprintf+0x2cc>
    400831bc:	11002022 	add	w2, w1, #0x8
    400831c0:	b9001a62 	str	w2, [x19, #24]
    400831c4:	b9401a62 	ldr	w2, [x19, #24]
    400831c8:	7100005f 	cmp	w2, #0x0
    400831cc:	540000ad 	b.le	400831e0 <vsnprintf+0x2c0>
    400831d0:	91002c01 	add	x1, x0, #0xb
    400831d4:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400831d8:	f9000261 	str	x1, [x19]
    400831dc:	14000004 	b	400831ec <vsnprintf+0x2cc>
    400831e0:	f9400662 	ldr	x2, [x19, #8]
    400831e4:	93407c20 	sxtw	x0, w1
    400831e8:	8b000040 	add	x0, x2, x0
    400831ec:	b9400000 	ldr	w0, [x0]
    400831f0:	93407c01 	sxtw	x1, w0
    400831f4:	f94027e3 	ldr	x3, [sp, #72]
    400831f8:	b94053e2 	ldr	w2, [sp, #80]
    400831fc:	910163e0 	add	x0, sp, #0x58
    40083200:	aa0203e4 	mov	x4, x2
    40083204:	52800142 	mov	w2, #0xa                   	// #10
    40083208:	97fffe34 	bl	40082ad8 <print_int>
		break;
    4008320c:	14000039 	b	400832f0 <vsnprintf+0x3d0>
	    case 1:
		print_int(&s, va_arg(va, long), 10, props);
    40083210:	b9401a61 	ldr	w1, [x19, #24]
    40083214:	f9400260 	ldr	x0, [x19]
    40083218:	7100003f 	cmp	w1, #0x0
    4008321c:	540000ab 	b.lt	40083230 <vsnprintf+0x310>  // b.tstop
    40083220:	91003c01 	add	x1, x0, #0xf
    40083224:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083228:	f9000261 	str	x1, [x19]
    4008322c:	1400000d 	b	40083260 <vsnprintf+0x340>
    40083230:	11002022 	add	w2, w1, #0x8
    40083234:	b9001a62 	str	w2, [x19, #24]
    40083238:	b9401a62 	ldr	w2, [x19, #24]
    4008323c:	7100005f 	cmp	w2, #0x0
    40083240:	540000ad 	b.le	40083254 <vsnprintf+0x334>
    40083244:	91003c01 	add	x1, x0, #0xf
    40083248:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008324c:	f9000261 	str	x1, [x19]
    40083250:	14000004 	b	40083260 <vsnprintf+0x340>
    40083254:	f9400662 	ldr	x2, [x19, #8]
    40083258:	93407c20 	sxtw	x0, w1
    4008325c:	8b000040 	add	x0, x2, x0
    40083260:	f9400001 	ldr	x1, [x0]
    40083264:	f94027e3 	ldr	x3, [sp, #72]
    40083268:	b94053e2 	ldr	w2, [sp, #80]
    4008326c:	910163e0 	add	x0, sp, #0x58
    40083270:	aa0203e4 	mov	x4, x2
    40083274:	52800142 	mov	w2, #0xa                   	// #10
    40083278:	97fffe18 	bl	40082ad8 <print_int>
		break;
    4008327c:	1400001d 	b	400832f0 <vsnprintf+0x3d0>
	    default:
		print_int(&s, va_arg(va, long long), 10, props);
    40083280:	b9401a61 	ldr	w1, [x19, #24]
    40083284:	f9400260 	ldr	x0, [x19]
    40083288:	7100003f 	cmp	w1, #0x0
    4008328c:	540000ab 	b.lt	400832a0 <vsnprintf+0x380>  // b.tstop
    40083290:	91003c01 	add	x1, x0, #0xf
    40083294:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083298:	f9000261 	str	x1, [x19]
    4008329c:	1400000d 	b	400832d0 <vsnprintf+0x3b0>
    400832a0:	11002022 	add	w2, w1, #0x8
    400832a4:	b9001a62 	str	w2, [x19, #24]
    400832a8:	b9401a62 	ldr	w2, [x19, #24]
    400832ac:	7100005f 	cmp	w2, #0x0
    400832b0:	540000ad 	b.le	400832c4 <vsnprintf+0x3a4>
    400832b4:	91003c01 	add	x1, x0, #0xf
    400832b8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400832bc:	f9000261 	str	x1, [x19]
    400832c0:	14000004 	b	400832d0 <vsnprintf+0x3b0>
    400832c4:	f9400662 	ldr	x2, [x19, #8]
    400832c8:	93407c20 	sxtw	x0, w1
    400832cc:	8b000040 	add	x0, x2, x0
    400832d0:	f9400001 	ldr	x1, [x0]
    400832d4:	f94027e3 	ldr	x3, [sp, #72]
    400832d8:	b94053e2 	ldr	w2, [sp, #80]
    400832dc:	910163e0 	add	x0, sp, #0x58
    400832e0:	aa0203e4 	mov	x4, x2
    400832e4:	52800142 	mov	w2, #0xa                   	// #10
    400832e8:	97fffdfc 	bl	40082ad8 <print_int>
		break;
    400832ec:	d503201f 	nop
	    }
	    break;
    400832f0:	140000fa 	b	400836d8 <vsnprintf+0x7b8>
    400832f4:	b9406fe0 	ldr	w0, [sp, #108]
    400832f8:	7100001f 	cmp	w0, #0x0
    400832fc:	540000a0 	b.eq	40083310 <vsnprintf+0x3f0>  // b.none
    40083300:	b9406fe0 	ldr	w0, [sp, #108]
    40083304:	7100041f 	cmp	w0, #0x1
    40083308:	540003e0 	b.eq	40083384 <vsnprintf+0x464>  // b.none
    4008330c:	1400003a 	b	400833f4 <vsnprintf+0x4d4>
	case 'u':
	    switch (nlong) {
	    case 0:
		print_unsigned(&s, va_arg(va, unsigned), 10, props);
    40083310:	b9401a61 	ldr	w1, [x19, #24]
    40083314:	f9400260 	ldr	x0, [x19]
    40083318:	7100003f 	cmp	w1, #0x0
    4008331c:	540000ab 	b.lt	40083330 <vsnprintf+0x410>  // b.tstop
    40083320:	91002c01 	add	x1, x0, #0xb
    40083324:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083328:	f9000261 	str	x1, [x19]
    4008332c:	1400000d 	b	40083360 <vsnprintf+0x440>
    40083330:	11002022 	add	w2, w1, #0x8
    40083334:	b9001a62 	str	w2, [x19, #24]
    40083338:	b9401a62 	ldr	w2, [x19, #24]
    4008333c:	7100005f 	cmp	w2, #0x0
    40083340:	540000ad 	b.le	40083354 <vsnprintf+0x434>
    40083344:	91002c01 	add	x1, x0, #0xb
    40083348:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008334c:	f9000261 	str	x1, [x19]
    40083350:	14000004 	b	40083360 <vsnprintf+0x440>
    40083354:	f9400662 	ldr	x2, [x19, #8]
    40083358:	93407c20 	sxtw	x0, w1
    4008335c:	8b000040 	add	x0, x2, x0
    40083360:	b9400000 	ldr	w0, [x0]
    40083364:	2a0003e1 	mov	w1, w0
    40083368:	f94027e3 	ldr	x3, [sp, #72]
    4008336c:	b94053e2 	ldr	w2, [sp, #80]
    40083370:	910163e0 	add	x0, sp, #0x58
    40083374:	aa0203e4 	mov	x4, x2
    40083378:	52800142 	mov	w2, #0xa                   	// #10
    4008337c:	97fffe40 	bl	40082c7c <print_unsigned>
		break;
    40083380:	14000039 	b	40083464 <vsnprintf+0x544>
	    case 1:
		print_unsigned(&s, va_arg(va, uint32_t), 10, props);
    40083384:	b9401a61 	ldr	w1, [x19, #24]
    40083388:	f9400260 	ldr	x0, [x19]
    4008338c:	7100003f 	cmp	w1, #0x0
    40083390:	540000ab 	b.lt	400833a4 <vsnprintf+0x484>  // b.tstop
    40083394:	91003c01 	add	x1, x0, #0xf
    40083398:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008339c:	f9000261 	str	x1, [x19]
    400833a0:	1400000d 	b	400833d4 <vsnprintf+0x4b4>
    400833a4:	11002022 	add	w2, w1, #0x8
    400833a8:	b9001a62 	str	w2, [x19, #24]
    400833ac:	b9401a62 	ldr	w2, [x19, #24]
    400833b0:	7100005f 	cmp	w2, #0x0
    400833b4:	540000ad 	b.le	400833c8 <vsnprintf+0x4a8>
    400833b8:	91003c01 	add	x1, x0, #0xf
    400833bc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400833c0:	f9000261 	str	x1, [x19]
    400833c4:	14000004 	b	400833d4 <vsnprintf+0x4b4>
    400833c8:	f9400662 	ldr	x2, [x19, #8]
    400833cc:	93407c20 	sxtw	x0, w1
    400833d0:	8b000040 	add	x0, x2, x0
    400833d4:	f9400001 	ldr	x1, [x0]
    400833d8:	f94027e3 	ldr	x3, [sp, #72]
    400833dc:	b94053e2 	ldr	w2, [sp, #80]
    400833e0:	910163e0 	add	x0, sp, #0x58
    400833e4:	aa0203e4 	mov	x4, x2
    400833e8:	52800142 	mov	w2, #0xa                   	// #10
    400833ec:	97fffe24 	bl	40082c7c <print_unsigned>
		break;
    400833f0:	1400001d 	b	40083464 <vsnprintf+0x544>
	    default:
		print_unsigned(&s, va_arg(va, uint32_t), 10, props);
    400833f4:	b9401a61 	ldr	w1, [x19, #24]
    400833f8:	f9400260 	ldr	x0, [x19]
    400833fc:	7100003f 	cmp	w1, #0x0
    40083400:	540000ab 	b.lt	40083414 <vsnprintf+0x4f4>  // b.tstop
    40083404:	91003c01 	add	x1, x0, #0xf
    40083408:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008340c:	f9000261 	str	x1, [x19]
    40083410:	1400000d 	b	40083444 <vsnprintf+0x524>
    40083414:	11002022 	add	w2, w1, #0x8
    40083418:	b9001a62 	str	w2, [x19, #24]
    4008341c:	b9401a62 	ldr	w2, [x19, #24]
    40083420:	7100005f 	cmp	w2, #0x0
    40083424:	540000ad 	b.le	40083438 <vsnprintf+0x518>
    40083428:	91003c01 	add	x1, x0, #0xf
    4008342c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083430:	f9000261 	str	x1, [x19]
    40083434:	14000004 	b	40083444 <vsnprintf+0x524>
    40083438:	f9400662 	ldr	x2, [x19, #8]
    4008343c:	93407c20 	sxtw	x0, w1
    40083440:	8b000040 	add	x0, x2, x0
    40083444:	f9400001 	ldr	x1, [x0]
    40083448:	f94027e3 	ldr	x3, [sp, #72]
    4008344c:	b94053e2 	ldr	w2, [sp, #80]
    40083450:	910163e0 	add	x0, sp, #0x58
    40083454:	aa0203e4 	mov	x4, x2
    40083458:	52800142 	mov	w2, #0xa                   	// #10
    4008345c:	97fffe08 	bl	40082c7c <print_unsigned>
		break;
    40083460:	d503201f 	nop
	    }
	    break;
    40083464:	1400009d 	b	400836d8 <vsnprintf+0x7b8>
    40083468:	b9406fe0 	ldr	w0, [sp, #108]
    4008346c:	7100001f 	cmp	w0, #0x0
    40083470:	540000a0 	b.eq	40083484 <vsnprintf+0x564>  // b.none
    40083474:	b9406fe0 	ldr	w0, [sp, #108]
    40083478:	7100041f 	cmp	w0, #0x1
    4008347c:	540003e0 	b.eq	400834f8 <vsnprintf+0x5d8>  // b.none
    40083480:	1400003a 	b	40083568 <vsnprintf+0x648>
	case 'x':
	    switch (nlong) {
	    case 0:
		print_unsigned(&s, va_arg(va, unsigned), 16, props);
    40083484:	b9401a61 	ldr	w1, [x19, #24]
    40083488:	f9400260 	ldr	x0, [x19]
    4008348c:	7100003f 	cmp	w1, #0x0
    40083490:	540000ab 	b.lt	400834a4 <vsnprintf+0x584>  // b.tstop
    40083494:	91002c01 	add	x1, x0, #0xb
    40083498:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008349c:	f9000261 	str	x1, [x19]
    400834a0:	1400000d 	b	400834d4 <vsnprintf+0x5b4>
    400834a4:	11002022 	add	w2, w1, #0x8
    400834a8:	b9001a62 	str	w2, [x19, #24]
    400834ac:	b9401a62 	ldr	w2, [x19, #24]
    400834b0:	7100005f 	cmp	w2, #0x0
    400834b4:	540000ad 	b.le	400834c8 <vsnprintf+0x5a8>
    400834b8:	91002c01 	add	x1, x0, #0xb
    400834bc:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400834c0:	f9000261 	str	x1, [x19]
    400834c4:	14000004 	b	400834d4 <vsnprintf+0x5b4>
    400834c8:	f9400662 	ldr	x2, [x19, #8]
    400834cc:	93407c20 	sxtw	x0, w1
    400834d0:	8b000040 	add	x0, x2, x0
    400834d4:	b9400000 	ldr	w0, [x0]
    400834d8:	2a0003e1 	mov	w1, w0
    400834dc:	f94027e3 	ldr	x3, [sp, #72]
    400834e0:	b94053e2 	ldr	w2, [sp, #80]
    400834e4:	910163e0 	add	x0, sp, #0x58
    400834e8:	aa0203e4 	mov	x4, x2
    400834ec:	52800202 	mov	w2, #0x10                  	// #16
    400834f0:	97fffde3 	bl	40082c7c <print_unsigned>
		break;
    400834f4:	14000039 	b	400835d8 <vsnprintf+0x6b8>
	    case 1:
		print_unsigned(&s, va_arg(va, uint32_t), 16, props);
    400834f8:	b9401a61 	ldr	w1, [x19, #24]
    400834fc:	f9400260 	ldr	x0, [x19]
    40083500:	7100003f 	cmp	w1, #0x0
    40083504:	540000ab 	b.lt	40083518 <vsnprintf+0x5f8>  // b.tstop
    40083508:	91003c01 	add	x1, x0, #0xf
    4008350c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083510:	f9000261 	str	x1, [x19]
    40083514:	1400000d 	b	40083548 <vsnprintf+0x628>
    40083518:	11002022 	add	w2, w1, #0x8
    4008351c:	b9001a62 	str	w2, [x19, #24]
    40083520:	b9401a62 	ldr	w2, [x19, #24]
    40083524:	7100005f 	cmp	w2, #0x0
    40083528:	540000ad 	b.le	4008353c <vsnprintf+0x61c>
    4008352c:	91003c01 	add	x1, x0, #0xf
    40083530:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083534:	f9000261 	str	x1, [x19]
    40083538:	14000004 	b	40083548 <vsnprintf+0x628>
    4008353c:	f9400662 	ldr	x2, [x19, #8]
    40083540:	93407c20 	sxtw	x0, w1
    40083544:	8b000040 	add	x0, x2, x0
    40083548:	f9400001 	ldr	x1, [x0]
    4008354c:	f94027e3 	ldr	x3, [sp, #72]
    40083550:	b94053e2 	ldr	w2, [sp, #80]
    40083554:	910163e0 	add	x0, sp, #0x58
    40083558:	aa0203e4 	mov	x4, x2
    4008355c:	52800202 	mov	w2, #0x10                  	// #16
    40083560:	97fffdc7 	bl	40082c7c <print_unsigned>
		break;
    40083564:	1400001d 	b	400835d8 <vsnprintf+0x6b8>
	    default:
		print_unsigned(&s, va_arg(va, uint32_t), 16, props);
    40083568:	b9401a61 	ldr	w1, [x19, #24]
    4008356c:	f9400260 	ldr	x0, [x19]
    40083570:	7100003f 	cmp	w1, #0x0
    40083574:	540000ab 	b.lt	40083588 <vsnprintf+0x668>  // b.tstop
    40083578:	91003c01 	add	x1, x0, #0xf
    4008357c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083580:	f9000261 	str	x1, [x19]
    40083584:	1400000d 	b	400835b8 <vsnprintf+0x698>
    40083588:	11002022 	add	w2, w1, #0x8
    4008358c:	b9001a62 	str	w2, [x19, #24]
    40083590:	b9401a62 	ldr	w2, [x19, #24]
    40083594:	7100005f 	cmp	w2, #0x0
    40083598:	540000ad 	b.le	400835ac <vsnprintf+0x68c>
    4008359c:	91003c01 	add	x1, x0, #0xf
    400835a0:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400835a4:	f9000261 	str	x1, [x19]
    400835a8:	14000004 	b	400835b8 <vsnprintf+0x698>
    400835ac:	f9400662 	ldr	x2, [x19, #8]
    400835b0:	93407c20 	sxtw	x0, w1
    400835b4:	8b000040 	add	x0, x2, x0
    400835b8:	f9400001 	ldr	x1, [x0]
    400835bc:	f94027e3 	ldr	x3, [sp, #72]
    400835c0:	b94053e2 	ldr	w2, [sp, #80]
    400835c4:	910163e0 	add	x0, sp, #0x58
    400835c8:	aa0203e4 	mov	x4, x2
    400835cc:	52800202 	mov	w2, #0x10                  	// #16
    400835d0:	97fffdab 	bl	40082c7c <print_unsigned>
		break;
    400835d4:	d503201f 	nop
	    }
	    break;
    400835d8:	14000040 	b	400836d8 <vsnprintf+0x7b8>
	case 'p':
	    props.alternate = true;
    400835dc:	52800020 	mov	w0, #0x1                   	// #1
    400835e0:	390143e0 	strb	w0, [sp, #80]
	    print_unsigned(&s, (uint32_t)va_arg(va, void *), 16, props);
    400835e4:	b9401a61 	ldr	w1, [x19, #24]
    400835e8:	f9400260 	ldr	x0, [x19]
    400835ec:	7100003f 	cmp	w1, #0x0
    400835f0:	540000ab 	b.lt	40083604 <vsnprintf+0x6e4>  // b.tstop
    400835f4:	91003c01 	add	x1, x0, #0xf
    400835f8:	927df021 	and	x1, x1, #0xfffffffffffffff8
    400835fc:	f9000261 	str	x1, [x19]
    40083600:	1400000d 	b	40083634 <vsnprintf+0x714>
    40083604:	11002022 	add	w2, w1, #0x8
    40083608:	b9001a62 	str	w2, [x19, #24]
    4008360c:	b9401a62 	ldr	w2, [x19, #24]
    40083610:	7100005f 	cmp	w2, #0x0
    40083614:	540000ad 	b.le	40083628 <vsnprintf+0x708>
    40083618:	91003c01 	add	x1, x0, #0xf
    4008361c:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083620:	f9000261 	str	x1, [x19]
    40083624:	14000004 	b	40083634 <vsnprintf+0x714>
    40083628:	f9400662 	ldr	x2, [x19, #8]
    4008362c:	93407c20 	sxtw	x0, w1
    40083630:	8b000040 	add	x0, x2, x0
    40083634:	f9400000 	ldr	x0, [x0]
    40083638:	aa0003e5 	mov	x5, x0
    4008363c:	f94027e2 	ldr	x2, [sp, #72]
    40083640:	b94053e1 	ldr	w1, [sp, #80]
    40083644:	910163e0 	add	x0, sp, #0x58
    40083648:	aa0203e3 	mov	x3, x2
    4008364c:	aa0103e4 	mov	x4, x1
    40083650:	52800202 	mov	w2, #0x10                  	// #16
    40083654:	aa0503e1 	mov	x1, x5
    40083658:	97fffd89 	bl	40082c7c <print_unsigned>
	    break;
    4008365c:	1400001f 	b	400836d8 <vsnprintf+0x7b8>
	case 's':
	    print_str(&s, va_arg(va, const char *), props);
    40083660:	b9401a61 	ldr	w1, [x19, #24]
    40083664:	f9400260 	ldr	x0, [x19]
    40083668:	7100003f 	cmp	w1, #0x0
    4008366c:	540000ab 	b.lt	40083680 <vsnprintf+0x760>  // b.tstop
    40083670:	91003c01 	add	x1, x0, #0xf
    40083674:	927df021 	and	x1, x1, #0xfffffffffffffff8
    40083678:	f9000261 	str	x1, [x19]
    4008367c:	1400000d 	b	400836b0 <vsnprintf+0x790>
    40083680:	11002022 	add	w2, w1, #0x8
    40083684:	b9001a62 	str	w2, [x19, #24]
    40083688:	b9401a62 	ldr	w2, [x19, #24]
    4008368c:	7100005f 	cmp	w2, #0x0
    40083690:	540000ad 	b.le	400836a4 <vsnprintf+0x784>
    40083694:	91003c01 	add	x1, x0, #0xf
    40083698:	927df021 	and	x1, x1, #0xfffffffffffffff8
    4008369c:	f9000261 	str	x1, [x19]
    400836a0:	14000004 	b	400836b0 <vsnprintf+0x790>
    400836a4:	f9400662 	ldr	x2, [x19, #8]
    400836a8:	93407c20 	sxtw	x0, w1
    400836ac:	8b000040 	add	x0, x2, x0
    400836b0:	f9400001 	ldr	x1, [x0]
    400836b4:	f94027e2 	ldr	x2, [sp, #72]
    400836b8:	b94053e3 	ldr	w3, [sp, #80]
    400836bc:	910163e0 	add	x0, sp, #0x58
    400836c0:	97fffcbe 	bl	400829b8 <print_str>
	    break;
    400836c4:	14000005 	b	400836d8 <vsnprintf+0x7b8>
	default:
	    addchar(&s, f);
    400836c8:	910163e0 	add	x0, sp, #0x58
    400836cc:	3941afe1 	ldrb	w1, [sp, #107]
    400836d0:	97fffc9f 	bl	4008294c <addchar>
	    break;
    400836d4:	d503201f 	nop
    while (*fmt) {
    400836d8:	f94017e0 	ldr	x0, [sp, #40]
    400836dc:	39400000 	ldrb	w0, [x0]
    400836e0:	7100001f 	cmp	w0, #0x0
    400836e4:	54ffc3a1 	b.ne	40082f58 <vsnprintf+0x38>  // b.any
	}
    }
    *s.buffer = 0;
    400836e8:	f9402fe0 	ldr	x0, [sp, #88]
    400836ec:	3900001f 	strb	wzr, [x0]
    return s.added;
    400836f0:	b94067e0 	ldr	w0, [sp, #100]
}
    400836f4:	f9400bf3 	ldr	x19, [sp, #16]
    400836f8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    400836fc:	d65f03c0 	ret

0000000040083700 <snprintf>:


int snprintf(char *buf, int size, const char *fmt, ...)
{
    40083700:	a9b57bfd 	stp	x29, x30, [sp, #-176]!
    40083704:	910003fd 	mov	x29, sp
    40083708:	f90027e0 	str	x0, [sp, #72]
    4008370c:	b90047e1 	str	w1, [sp, #68]
    40083710:	f9001fe2 	str	x2, [sp, #56]
    40083714:	f90047e3 	str	x3, [sp, #136]
    40083718:	f9004be4 	str	x4, [sp, #144]
    4008371c:	f9004fe5 	str	x5, [sp, #152]
    40083720:	f90053e6 	str	x6, [sp, #160]
    40083724:	f90057e7 	str	x7, [sp, #168]
    va_list va;
    int r;

    va_start(va, fmt);
    40083728:	9102c3e0 	add	x0, sp, #0xb0
    4008372c:	f9002fe0 	str	x0, [sp, #88]
    40083730:	9102c3e0 	add	x0, sp, #0xb0
    40083734:	f90033e0 	str	x0, [sp, #96]
    40083738:	910203e0 	add	x0, sp, #0x80
    4008373c:	f90037e0 	str	x0, [sp, #104]
    40083740:	128004e0 	mov	w0, #0xffffffd8            	// #-40
    40083744:	b90073e0 	str	w0, [sp, #112]
    40083748:	b90077ff 	str	wzr, [sp, #116]
    r = vsnprintf(buf, size, fmt, va);
    4008374c:	910043e2 	add	x2, sp, #0x10
    40083750:	910163e3 	add	x3, sp, #0x58
    40083754:	a9400460 	ldp	x0, x1, [x3]
    40083758:	a9000440 	stp	x0, x1, [x2]
    4008375c:	a9410460 	ldp	x0, x1, [x3, #16]
    40083760:	a9010440 	stp	x0, x1, [x2, #16]
    40083764:	910043e0 	add	x0, sp, #0x10
    40083768:	aa0003e3 	mov	x3, x0
    4008376c:	f9401fe2 	ldr	x2, [sp, #56]
    40083770:	b94047e1 	ldr	w1, [sp, #68]
    40083774:	f94027e0 	ldr	x0, [sp, #72]
    40083778:	97fffdea 	bl	40082f20 <vsnprintf>
    4008377c:	b9007fe0 	str	w0, [sp, #124]
    va_end(va);
    return r;
    40083780:	b9407fe0 	ldr	w0, [sp, #124]
}
    40083784:	a8cb7bfd 	ldp	x29, x30, [sp], #176
    40083788:	d65f03c0 	ret

000000004008378c <vprintf>:

int vprintf(const char *fmt, va_list va)
{
    4008378c:	d120c3ff 	sub	sp, sp, #0x830
    40083790:	a9007bfd 	stp	x29, x30, [sp]
    40083794:	910003fd 	mov	x29, sp
    40083798:	f9000bf3 	str	x19, [sp, #16]
    4008379c:	f90027e0 	str	x0, [sp, #72]
    400837a0:	aa0103f3 	mov	x19, x1
    char buf[BUFSZ];
    int r;

    r = vsnprintf(buf, sizeof(buf), fmt, va);
    400837a4:	910083e2 	add	x2, sp, #0x20
    400837a8:	aa1303e3 	mov	x3, x19
    400837ac:	a9400460 	ldp	x0, x1, [x3]
    400837b0:	a9000440 	stp	x0, x1, [x2]
    400837b4:	a9410460 	ldp	x0, x1, [x3, #16]
    400837b8:	a9010440 	stp	x0, x1, [x2, #16]
    400837bc:	910083e1 	add	x1, sp, #0x20
    400837c0:	910163e0 	add	x0, sp, #0x58
    400837c4:	aa0103e3 	mov	x3, x1
    400837c8:	f94027e2 	ldr	x2, [sp, #72]
    400837cc:	5280fa01 	mov	w1, #0x7d0                 	// #2000
    400837d0:	97fffdd4 	bl	40082f20 <vsnprintf>
    400837d4:	b9082fe0 	str	w0, [sp, #2092]
    puts(buf);
    400837d8:	910163e0 	add	x0, sp, #0x58
    400837dc:	97fffc40 	bl	400828dc <uart_putstr>
    return r;
    400837e0:	b9482fe0 	ldr	w0, [sp, #2092]
}
    400837e4:	f9400bf3 	ldr	x19, [sp, #16]
    400837e8:	a9407bfd 	ldp	x29, x30, [sp]
    400837ec:	9120c3ff 	add	sp, sp, #0x830
    400837f0:	d65f03c0 	ret

00000000400837f4 <printf>:

int printf(const char *fmt, ...)
{
    400837f4:	d12203ff 	sub	sp, sp, #0x880
    400837f8:	a9007bfd 	stp	x29, x30, [sp]
    400837fc:	910003fd 	mov	x29, sp
    40083800:	f9001fe0 	str	x0, [sp, #56]
    40083804:	f90427e1 	str	x1, [sp, #2120]
    40083808:	f9042be2 	str	x2, [sp, #2128]
    4008380c:	f9042fe3 	str	x3, [sp, #2136]
    40083810:	f90433e4 	str	x4, [sp, #2144]
    40083814:	f90437e5 	str	x5, [sp, #2152]
    40083818:	f9043be6 	str	x6, [sp, #2160]
    4008381c:	f9043fe7 	str	x7, [sp, #2168]
    va_list va;
    char buf[BUFSZ];
    int r;

    va_start(va, fmt);
    40083820:	912203e0 	add	x0, sp, #0x880
    40083824:	f9040fe0 	str	x0, [sp, #2072]
    40083828:	912203e0 	add	x0, sp, #0x880
    4008382c:	f90413e0 	str	x0, [sp, #2080]
    40083830:	912103e0 	add	x0, sp, #0x840
    40083834:	f90417e0 	str	x0, [sp, #2088]
    40083838:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    4008383c:	b90833e0 	str	w0, [sp, #2096]
    40083840:	b90837ff 	str	wzr, [sp, #2100]
    r = vsnprintf(buf, sizeof buf, fmt, va);
    40083844:	910043e2 	add	x2, sp, #0x10
    40083848:	912063e3 	add	x3, sp, #0x818
    4008384c:	a9400460 	ldp	x0, x1, [x3]
    40083850:	a9000440 	stp	x0, x1, [x2]
    40083854:	a9410460 	ldp	x0, x1, [x3, #16]
    40083858:	a9010440 	stp	x0, x1, [x2, #16]
    4008385c:	910043e1 	add	x1, sp, #0x10
    40083860:	910123e0 	add	x0, sp, #0x48
    40083864:	aa0103e3 	mov	x3, x1
    40083868:	f9401fe2 	ldr	x2, [sp, #56]
    4008386c:	5280fa01 	mov	w1, #0x7d0                 	// #2000
    40083870:	97fffdac 	bl	40082f20 <vsnprintf>
    40083874:	b9083fe0 	str	w0, [sp, #2108]
    va_end(va);

    puts(buf);
    40083878:	910123e0 	add	x0, sp, #0x48
    4008387c:	97fffc18 	bl	400828dc <uart_putstr>

    return r;
    40083880:	b9483fe0 	ldr	w0, [sp, #2108]
}
    40083884:	a9407bfd 	ldp	x29, x30, [sp]
    40083888:	912203ff 	add	sp, sp, #0x880
    4008388c:	d65f03c0 	ret

0000000040083890 <warning>:

int warning(const char *fmt, ...)
{
    40083890:	d12203ff 	sub	sp, sp, #0x880
    40083894:	a9007bfd 	stp	x29, x30, [sp]
    40083898:	910003fd 	mov	x29, sp
    4008389c:	f9001fe0 	str	x0, [sp, #56]
    400838a0:	f90427e1 	str	x1, [sp, #2120]
    400838a4:	f9042be2 	str	x2, [sp, #2128]
    400838a8:	f9042fe3 	str	x3, [sp, #2136]
    400838ac:	f90433e4 	str	x4, [sp, #2144]
    400838b0:	f90437e5 	str	x5, [sp, #2152]
    400838b4:	f9043be6 	str	x6, [sp, #2160]
    400838b8:	f9043fe7 	str	x7, [sp, #2168]
    va_list va;
    char buf[BUFSZ];
    int r;

    va_start(va, fmt);
    400838bc:	912203e0 	add	x0, sp, #0x880
    400838c0:	f9040fe0 	str	x0, [sp, #2072]
    400838c4:	912203e0 	add	x0, sp, #0x880
    400838c8:	f90413e0 	str	x0, [sp, #2080]
    400838cc:	912103e0 	add	x0, sp, #0x840
    400838d0:	f90417e0 	str	x0, [sp, #2088]
    400838d4:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    400838d8:	b90833e0 	str	w0, [sp, #2096]
    400838dc:	b90837ff 	str	wzr, [sp, #2100]
    r = vsnprintf(buf, sizeof buf, fmt, va);
    400838e0:	910043e2 	add	x2, sp, #0x10
    400838e4:	912063e3 	add	x3, sp, #0x818
    400838e8:	a9400460 	ldp	x0, x1, [x3]
    400838ec:	a9000440 	stp	x0, x1, [x2]
    400838f0:	a9410460 	ldp	x0, x1, [x3, #16]
    400838f4:	a9010440 	stp	x0, x1, [x2, #16]
    400838f8:	910043e1 	add	x1, sp, #0x10
    400838fc:	910123e0 	add	x0, sp, #0x48
    40083900:	aa0103e3 	mov	x3, x1
    40083904:	f9401fe2 	ldr	x2, [sp, #56]
    40083908:	5280fa01 	mov	w1, #0x7d0                 	// #2000
    4008390c:	97fffd85 	bl	40082f20 <vsnprintf>
    40083910:	b9083fe0 	str	w0, [sp, #2108]
    va_end(va);

    puts(buf);
    40083914:	910123e0 	add	x0, sp, #0x48
    40083918:	97fffbf1 	bl	400828dc <uart_putstr>

    return r;
    4008391c:	b9483fe0 	ldr	w0, [sp, #2108]
}
    40083920:	a9407bfd 	ldp	x29, x30, [sp]
    40083924:	912203ff 	add	sp, sp, #0x880
    40083928:	d65f03c0 	ret

000000004008392c <error>:

int error(const char *fmt, ...)
{
    4008392c:	d12203ff 	sub	sp, sp, #0x880
    40083930:	a9007bfd 	stp	x29, x30, [sp]
    40083934:	910003fd 	mov	x29, sp
    40083938:	f9001fe0 	str	x0, [sp, #56]
    4008393c:	f90427e1 	str	x1, [sp, #2120]
    40083940:	f9042be2 	str	x2, [sp, #2128]
    40083944:	f9042fe3 	str	x3, [sp, #2136]
    40083948:	f90433e4 	str	x4, [sp, #2144]
    4008394c:	f90437e5 	str	x5, [sp, #2152]
    40083950:	f9043be6 	str	x6, [sp, #2160]
    40083954:	f9043fe7 	str	x7, [sp, #2168]
    va_list va;
    char buf[BUFSZ];
    int r;

    va_start(va, fmt);
    40083958:	912203e0 	add	x0, sp, #0x880
    4008395c:	f9040fe0 	str	x0, [sp, #2072]
    40083960:	912203e0 	add	x0, sp, #0x880
    40083964:	f90413e0 	str	x0, [sp, #2080]
    40083968:	912103e0 	add	x0, sp, #0x840
    4008396c:	f90417e0 	str	x0, [sp, #2088]
    40083970:	128006e0 	mov	w0, #0xffffffc8            	// #-56
    40083974:	b90833e0 	str	w0, [sp, #2096]
    40083978:	b90837ff 	str	wzr, [sp, #2100]
    r = vsnprintf(buf, sizeof buf, fmt, va);
    4008397c:	910043e2 	add	x2, sp, #0x10
    40083980:	912063e3 	add	x3, sp, #0x818
    40083984:	a9400460 	ldp	x0, x1, [x3]
    40083988:	a9000440 	stp	x0, x1, [x2]
    4008398c:	a9410460 	ldp	x0, x1, [x3, #16]
    40083990:	a9010440 	stp	x0, x1, [x2, #16]
    40083994:	910043e1 	add	x1, sp, #0x10
    40083998:	910123e0 	add	x0, sp, #0x48
    4008399c:	aa0103e3 	mov	x3, x1
    400839a0:	f9401fe2 	ldr	x2, [sp, #56]
    400839a4:	5280fa01 	mov	w1, #0x7d0                 	// #2000
    400839a8:	97fffd5e 	bl	40082f20 <vsnprintf>
    400839ac:	b9083fe0 	str	w0, [sp, #2108]
    va_end(va);

    puts(buf);
    400839b0:	910123e0 	add	x0, sp, #0x48
    400839b4:	97fffbca 	bl	400828dc <uart_putstr>

    return r;
    400839b8:	b9483fe0 	ldr	w0, [sp, #2108]
}
    400839bc:	a9407bfd 	ldp	x29, x30, [sp]
    400839c0:	912203ff 	add	sp, sp, #0x880
    400839c4:	d65f03c0 	ret

00000000400839c8 <binstr>:

void binstr(uint32_t x, char out[BINSTR_SZ])
{
    400839c8:	d100c3ff 	sub	sp, sp, #0x30
    400839cc:	f90007e0 	str	x0, [sp, #8]
    400839d0:	f90003e1 	str	x1, [sp]
	int i;
	char *c;
	int n;

	n = sizeof(uint32_t) * 8;
    400839d4:	52800800 	mov	w0, #0x40                  	// #64
    400839d8:	b9001fe0 	str	w0, [sp, #28]
	i = 0;
    400839dc:	b9002fff 	str	wzr, [sp, #44]
	c = &out[0];
    400839e0:	f94003e0 	ldr	x0, [sp]
    400839e4:	f90013e0 	str	x0, [sp, #32]
	for (;;) {
		*c++ = (x & (1ul << (n - i - 1))) ? '1' : '0';
    400839e8:	b9401fe1 	ldr	w1, [sp, #28]
    400839ec:	b9402fe0 	ldr	w0, [sp, #44]
    400839f0:	4b000020 	sub	w0, w1, w0
    400839f4:	51000400 	sub	w0, w0, #0x1
    400839f8:	f94007e1 	ldr	x1, [sp, #8]
    400839fc:	9ac02420 	lsr	x0, x1, x0
    40083a00:	92400000 	and	x0, x0, #0x1
    40083a04:	f100001f 	cmp	x0, #0x0
    40083a08:	54000060 	b.eq	40083a14 <binstr+0x4c>  // b.none
    40083a0c:	52800621 	mov	w1, #0x31                  	// #49
    40083a10:	14000002 	b	40083a18 <binstr+0x50>
    40083a14:	52800601 	mov	w1, #0x30                  	// #48
    40083a18:	f94013e0 	ldr	x0, [sp, #32]
    40083a1c:	91000402 	add	x2, x0, #0x1
    40083a20:	f90013e2 	str	x2, [sp, #32]
    40083a24:	39000001 	strb	w1, [x0]
		i++;
    40083a28:	b9402fe0 	ldr	w0, [sp, #44]
    40083a2c:	11000400 	add	w0, w0, #0x1
    40083a30:	b9002fe0 	str	w0, [sp, #44]

		if (i == n) {
    40083a34:	b9402fe1 	ldr	w1, [sp, #44]
    40083a38:	b9401fe0 	ldr	w0, [sp, #28]
    40083a3c:	6b00003f 	cmp	w1, w0
    40083a40:	54000081 	b.ne	40083a50 <binstr+0x88>  // b.any
			*c = '\0';
    40083a44:	f94013e0 	ldr	x0, [sp, #32]
    40083a48:	3900001f 	strb	wzr, [x0]
			break;
    40083a4c:	1400000b 	b	40083a78 <binstr+0xb0>
		}
		if (i % 4 == 0)
    40083a50:	b9402fe0 	ldr	w0, [sp, #44]
    40083a54:	12000400 	and	w0, w0, #0x3
    40083a58:	7100001f 	cmp	w0, #0x0
    40083a5c:	54fffc61 	b.ne	400839e8 <binstr+0x20>  // b.any
			*c++ = '\'';
    40083a60:	f94013e0 	ldr	x0, [sp, #32]
    40083a64:	91000401 	add	x1, x0, #0x1
    40083a68:	f90013e1 	str	x1, [sp, #32]
    40083a6c:	528004e1 	mov	w1, #0x27                  	// #39
    40083a70:	39000001 	strb	w1, [x0]
		*c++ = (x & (1ul << (n - i - 1))) ? '1' : '0';
    40083a74:	17ffffdd 	b	400839e8 <binstr+0x20>
	}
	// assert(c + 1 - &out[0] == BINSTR_SZ);
}
    40083a78:	d503201f 	nop
    40083a7c:	9100c3ff 	add	sp, sp, #0x30
    40083a80:	d65f03c0 	ret

0000000040083a84 <print_binstr>:

void print_binstr(uint32_t x)
{
    40083a84:	a9b97bfd 	stp	x29, x30, [sp, #-112]!
    40083a88:	910003fd 	mov	x29, sp
    40083a8c:	f9000fe0 	str	x0, [sp, #24]
	char out[BINSTR_SZ];
	binstr(x, out);
    40083a90:	910083e0 	add	x0, sp, #0x20
    40083a94:	aa0003e1 	mov	x1, x0
    40083a98:	f9400fe0 	ldr	x0, [sp, #24]
    40083a9c:	97ffffcb 	bl	400839c8 <binstr>
	printf("%s", out);
    40083aa0:	910083e0 	add	x0, sp, #0x20
    40083aa4:	aa0003e1 	mov	x1, x0
    40083aa8:	b0000000 	adrp	x0, 40084000 <memmove+0x58>
    40083aac:	91112000 	add	x0, x0, #0x448
    40083ab0:	97ffff51 	bl	400837f4 <printf>
}
    40083ab4:	d503201f 	nop
    40083ab8:	a8c77bfd 	ldp	x29, x30, [sp], #112
    40083abc:	d65f03c0 	ret

0000000040083ac0 <init_mmu>:

/* ldr x0, =0x40084000 need change */
init_mmu:
    // 设置 Translation Table Base Register 0 (TTBR0_EL1)
    // ldr x0, =0x40088000
    msr ttbr0_el1, x0
    40083ac0:	d5182000 	msr	ttbr0_el1, x0
    msr ttbr1_el1, x0
    40083ac4:	d5182020 	msr	ttbr1_el1, x0
    // 设置 Translation Control Register (TCR_EL1)
    ldr x0, =(TCR_VALUE)
    40083ac8:	58000140 	ldr	x0, 40083af0 <init_mmu+0x30>
    msr tcr_el1, x0
    40083acc:	d5182040 	msr	tcr_el1, x0
    // 设置 MAIR_EL1 (Memory Attribute Indirection Register)
    ldr x0, =(MAIR_VALUE)
    40083ad0:	58000140 	ldr	x0, 40083af8 <init_mmu+0x38>
    msr mair_el1, x0
    40083ad4:	d518a200 	msr	mair_el1, x0
    

    // 设置 SCTLR_EL1 (System Control Register) 以启用MMU
    mrs x0, sctlr_el1
    40083ad8:	d5381000 	mrs	x0, sctlr_el1
    orr x0, x0, #(1 << 0) // 设置 SCTLR_EL1.M 位以启用 MMU
    40083adc:	b2400000 	orr	x0, x0, #0x1
    msr sctlr_el1, x0
    40083ae0:	d5181000 	msr	sctlr_el1, x0
    
    // 清空TLB
    dsb sy // 确保之前所有内存访问完成
    40083ae4:	d5033f9f 	dsb	sy
    isb    // 确保所有指令都执行完成
    40083ae8:	d5033fdf 	isb

    40083aec:	d65f03c0 	ret
    40083af0:	b5003500 	.word	0xb5003500
    40083af4:	00000000 	.word	0x00000000
    40083af8:	0044ff00 	.word	0x0044ff00
    40083afc:	00000000 	.word	0x00000000

0000000040083b00 <init_page_table>:
static uint64_t pt0[512] __attribute__((aligned(4096))) = {-1};
static uint64_t pt1[512] __attribute__((aligned(4096))) = {-1};

static bool mmu_enable_flag = -1;

void init_page_table() {
    40083b00:	d10043ff 	sub	sp, sp, #0x10
    // 清空页表
    for (int i = 0; i < 512; ++i) {
    40083b04:	b9000fff 	str	wzr, [sp, #12]
    40083b08:	14000008 	b	40083b28 <init_page_table+0x28>
        pt0[i] = 0;
    40083b0c:	f0000000 	adrp	x0, 40086000 <pt0>
    40083b10:	91000000 	add	x0, x0, #0x0
    40083b14:	b9800fe1 	ldrsw	x1, [sp, #12]
    40083b18:	f821781f 	str	xzr, [x0, x1, lsl #3]
    for (int i = 0; i < 512; ++i) {
    40083b1c:	b9400fe0 	ldr	w0, [sp, #12]
    40083b20:	11000400 	add	w0, w0, #0x1
    40083b24:	b9000fe0 	str	w0, [sp, #12]
    40083b28:	b9400fe0 	ldr	w0, [sp, #12]
    40083b2c:	7107fc1f 	cmp	w0, #0x1ff
    40083b30:	54fffeed 	b.le	40083b0c <init_page_table+0xc>
    }
    for (int i = 0; i < 512; ++i) {
    40083b34:	b9000bff 	str	wzr, [sp, #8]
    40083b38:	14000008 	b	40083b58 <init_page_table+0x58>
        pt1[i] = 0;
    40083b3c:	90000020 	adrp	x0, 40087000 <pt1>
    40083b40:	91000000 	add	x0, x0, #0x0
    40083b44:	b9800be1 	ldrsw	x1, [sp, #8]
    40083b48:	f821781f 	str	xzr, [x0, x1, lsl #3]
    for (int i = 0; i < 512; ++i) {
    40083b4c:	b9400be0 	ldr	w0, [sp, #8]
    40083b50:	11000400 	add	w0, w0, #0x1
    40083b54:	b9000be0 	str	w0, [sp, #8]
    40083b58:	b9400be0 	ldr	w0, [sp, #8]
    40083b5c:	7107fc1f 	cmp	w0, #0x1ff
    40083b60:	54fffeed 	b.le	40083b3c <init_page_table+0x3c>
    }

    pt0[0] = (uint64_t)pt1 + MM_TYPE_TABLE;    // 512 G
    40083b64:	90000020 	adrp	x0, 40087000 <pt1>
    40083b68:	91000000 	add	x0, x0, #0x0
    40083b6c:	91000c01 	add	x1, x0, #0x3
    40083b70:	f0000000 	adrp	x0, 40086000 <pt0>
    40083b74:	91000000 	add	x0, x0, #0x0
    40083b78:	f9000001 	str	x1, [x0]

    pt1[0] = (0          + PTE_DEVICE_MEMORY);  // 0x0000_0000 0x4000_0000
    40083b7c:	90000020 	adrp	x0, 40087000 <pt1>
    40083b80:	91000000 	add	x0, x0, #0x0
    40083b84:	d2808021 	mov	x1, #0x401                 	// #1025
    40083b88:	f9000001 	str	x1, [x0]
    pt1[1] = (0x40000000 + PTE_NORMAL_MEMORY);  // 0x4000_0000 0x8000_0000
    40083b8c:	90000020 	adrp	x0, 40087000 <pt1>
    40083b90:	91000000 	add	x0, x0, #0x0
    40083b94:	d280e0a1 	mov	x1, #0x705                 	// #1797
    40083b98:	f2a80001 	movk	x1, #0x4000, lsl #16
    40083b9c:	f9000401 	str	x1, [x0, #8]
}
    40083ba0:	d503201f 	nop
    40083ba4:	910043ff 	add	sp, sp, #0x10
    40083ba8:	d65f03c0 	ret

0000000040083bac <enable_mmu>:

extern void init_mmu(uint64_t);

void enable_mmu() {
    40083bac:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    40083bb0:	910003fd 	mov	x29, sp
    init_mmu((uint64_t)(void*)pt0);
    40083bb4:	f0000000 	adrp	x0, 40086000 <pt0>
    40083bb8:	91000000 	add	x0, x0, #0x0
    40083bbc:	97ffffc1 	bl	40083ac0 <init_mmu>
    40083bc0:	d503201f 	nop
    40083bc4:	a8c17bfd 	ldp	x29, x30, [sp], #16
    40083bc8:	d65f03c0 	ret

0000000040083bcc <strlen>:

#include "aj_string.h"
#include "aj_types.h"

unsigned long strlen(const char *buf)
{
    40083bcc:	d10083ff 	sub	sp, sp, #0x20
    40083bd0:	f90007e0 	str	x0, [sp, #8]
    unsigned long len = 0;
    40083bd4:	f9000fff 	str	xzr, [sp, #24]

    while (*buf++)
    40083bd8:	14000004 	b	40083be8 <strlen+0x1c>
	++len;
    40083bdc:	f9400fe0 	ldr	x0, [sp, #24]
    40083be0:	91000400 	add	x0, x0, #0x1
    40083be4:	f9000fe0 	str	x0, [sp, #24]
    while (*buf++)
    40083be8:	f94007e0 	ldr	x0, [sp, #8]
    40083bec:	91000401 	add	x1, x0, #0x1
    40083bf0:	f90007e1 	str	x1, [sp, #8]
    40083bf4:	39400000 	ldrb	w0, [x0]
    40083bf8:	7100001f 	cmp	w0, #0x0
    40083bfc:	54ffff01 	b.ne	40083bdc <strlen+0x10>  // b.any
    return len;
    40083c00:	f9400fe0 	ldr	x0, [sp, #24]
}
    40083c04:	910083ff 	add	sp, sp, #0x20
    40083c08:	d65f03c0 	ret

0000000040083c0c <strcat>:

char *strcat(char *dest, const char *src)
{
    40083c0c:	d10083ff 	sub	sp, sp, #0x20
    40083c10:	f90007e0 	str	x0, [sp, #8]
    40083c14:	f90003e1 	str	x1, [sp]
    char *p = dest;
    40083c18:	f94007e0 	ldr	x0, [sp, #8]
    40083c1c:	f9000fe0 	str	x0, [sp, #24]

    while (*p)
    40083c20:	14000004 	b	40083c30 <strcat+0x24>
	++p;
    40083c24:	f9400fe0 	ldr	x0, [sp, #24]
    40083c28:	91000400 	add	x0, x0, #0x1
    40083c2c:	f9000fe0 	str	x0, [sp, #24]
    while (*p)
    40083c30:	f9400fe0 	ldr	x0, [sp, #24]
    40083c34:	39400000 	ldrb	w0, [x0]
    40083c38:	7100001f 	cmp	w0, #0x0
    40083c3c:	54ffff41 	b.ne	40083c24 <strcat+0x18>  // b.any
    while ((*p++ = *src++) != 0)
    40083c40:	d503201f 	nop
    40083c44:	f94003e1 	ldr	x1, [sp]
    40083c48:	91000420 	add	x0, x1, #0x1
    40083c4c:	f90003e0 	str	x0, [sp]
    40083c50:	f9400fe0 	ldr	x0, [sp, #24]
    40083c54:	91000402 	add	x2, x0, #0x1
    40083c58:	f9000fe2 	str	x2, [sp, #24]
    40083c5c:	39400021 	ldrb	w1, [x1]
    40083c60:	39000001 	strb	w1, [x0]
    40083c64:	39400000 	ldrb	w0, [x0]
    40083c68:	7100001f 	cmp	w0, #0x0
    40083c6c:	54fffec1 	b.ne	40083c44 <strcat+0x38>  // b.any
	;
    return dest;
    40083c70:	f94007e0 	ldr	x0, [sp, #8]
}
    40083c74:	910083ff 	add	sp, sp, #0x20
    40083c78:	d65f03c0 	ret

0000000040083c7c <strcpy>:

char *strcpy(char *dest, const char *src)
{
    40083c7c:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40083c80:	910003fd 	mov	x29, sp
    40083c84:	f9000fe0 	str	x0, [sp, #24]
    40083c88:	f9000be1 	str	x1, [sp, #16]
    *dest = 0;
    40083c8c:	f9400fe0 	ldr	x0, [sp, #24]
    40083c90:	3900001f 	strb	wzr, [x0]
    return strcat(dest, src);
    40083c94:	f9400be1 	ldr	x1, [sp, #16]
    40083c98:	f9400fe0 	ldr	x0, [sp, #24]
    40083c9c:	97ffffdc 	bl	40083c0c <strcat>
}
    40083ca0:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40083ca4:	d65f03c0 	ret

0000000040083ca8 <strncmp>:

int strncmp(const char *a, const char *b, size_t n)
{
    40083ca8:	d10083ff 	sub	sp, sp, #0x20
    40083cac:	f9000fe0 	str	x0, [sp, #24]
    40083cb0:	f9000be1 	str	x1, [sp, #16]
    40083cb4:	f90007e2 	str	x2, [sp, #8]
    for (; n--; ++a, ++b)
    40083cb8:	14000018 	b	40083d18 <strncmp+0x70>
        if (*a != *b || *a == '\0')
    40083cbc:	f9400fe0 	ldr	x0, [sp, #24]
    40083cc0:	39400001 	ldrb	w1, [x0]
    40083cc4:	f9400be0 	ldr	x0, [sp, #16]
    40083cc8:	39400000 	ldrb	w0, [x0]
    40083ccc:	6b00003f 	cmp	w1, w0
    40083cd0:	540000a1 	b.ne	40083ce4 <strncmp+0x3c>  // b.any
    40083cd4:	f9400fe0 	ldr	x0, [sp, #24]
    40083cd8:	39400000 	ldrb	w0, [x0]
    40083cdc:	7100001f 	cmp	w0, #0x0
    40083ce0:	54000101 	b.ne	40083d00 <strncmp+0x58>  // b.any
            return *a - *b;
    40083ce4:	f9400fe0 	ldr	x0, [sp, #24]
    40083ce8:	39400000 	ldrb	w0, [x0]
    40083cec:	2a0003e1 	mov	w1, w0
    40083cf0:	f9400be0 	ldr	x0, [sp, #16]
    40083cf4:	39400000 	ldrb	w0, [x0]
    40083cf8:	4b000020 	sub	w0, w1, w0
    40083cfc:	1400000d 	b	40083d30 <strncmp+0x88>
    for (; n--; ++a, ++b)
    40083d00:	f9400fe0 	ldr	x0, [sp, #24]
    40083d04:	91000400 	add	x0, x0, #0x1
    40083d08:	f9000fe0 	str	x0, [sp, #24]
    40083d0c:	f9400be0 	ldr	x0, [sp, #16]
    40083d10:	91000400 	add	x0, x0, #0x1
    40083d14:	f9000be0 	str	x0, [sp, #16]
    40083d18:	f94007e0 	ldr	x0, [sp, #8]
    40083d1c:	d1000401 	sub	x1, x0, #0x1
    40083d20:	f90007e1 	str	x1, [sp, #8]
    40083d24:	f100001f 	cmp	x0, #0x0
    40083d28:	54fffca1 	b.ne	40083cbc <strncmp+0x14>  // b.any

    return 0;
    40083d2c:	52800000 	mov	w0, #0x0                   	// #0
}
    40083d30:	910083ff 	add	sp, sp, #0x20
    40083d34:	d65f03c0 	ret

0000000040083d38 <strcmp>:

int strcmp(const char *a, const char *b)
{
    40083d38:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40083d3c:	910003fd 	mov	x29, sp
    40083d40:	f9000fe0 	str	x0, [sp, #24]
    40083d44:	f9000be1 	str	x1, [sp, #16]
    return strncmp(a, b, SIZE_MAX);
    40083d48:	92f00002 	mov	x2, #0x7fffffffffffffff    	// #9223372036854775807
    40083d4c:	f9400be1 	ldr	x1, [sp, #16]
    40083d50:	f9400fe0 	ldr	x0, [sp, #24]
    40083d54:	97ffffd5 	bl	40083ca8 <strncmp>
}
    40083d58:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40083d5c:	d65f03c0 	ret

0000000040083d60 <strchr>:

char *strchr(const char *s, int c)
{
    40083d60:	d10043ff 	sub	sp, sp, #0x10
    40083d64:	f90007e0 	str	x0, [sp, #8]
    40083d68:	b90007e1 	str	w1, [sp, #4]
    while (*s != (char)c)
    40083d6c:	14000009 	b	40083d90 <strchr+0x30>
	if (*s++ == '\0')
    40083d70:	f94007e0 	ldr	x0, [sp, #8]
    40083d74:	91000401 	add	x1, x0, #0x1
    40083d78:	f90007e1 	str	x1, [sp, #8]
    40083d7c:	39400000 	ldrb	w0, [x0]
    40083d80:	7100001f 	cmp	w0, #0x0
    40083d84:	54000061 	b.ne	40083d90 <strchr+0x30>  // b.any
	    return NULL;
    40083d88:	d2800000 	mov	x0, #0x0                   	// #0
    40083d8c:	14000008 	b	40083dac <strchr+0x4c>
    while (*s != (char)c)
    40083d90:	f94007e0 	ldr	x0, [sp, #8]
    40083d94:	39400001 	ldrb	w1, [x0]
    40083d98:	b94007e0 	ldr	w0, [sp, #4]
    40083d9c:	12001c00 	and	w0, w0, #0xff
    40083da0:	6b00003f 	cmp	w1, w0
    40083da4:	54fffe61 	b.ne	40083d70 <strchr+0x10>  // b.any
    return (char *)s;
    40083da8:	f94007e0 	ldr	x0, [sp, #8]
}
    40083dac:	910043ff 	add	sp, sp, #0x10
    40083db0:	d65f03c0 	ret

0000000040083db4 <strstr>:

char *strstr(const char *s1, const char *s2)
{
    40083db4:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
    40083db8:	910003fd 	mov	x29, sp
    40083dbc:	f9000fe0 	str	x0, [sp, #24]
    40083dc0:	f9000be1 	str	x1, [sp, #16]
    size_t l1, l2;

    l2 = strlen(s2);
    40083dc4:	f9400be0 	ldr	x0, [sp, #16]
    40083dc8:	97ffff81 	bl	40083bcc <strlen>
    40083dcc:	f90013e0 	str	x0, [sp, #32]
    if (!l2)
    40083dd0:	f94013e0 	ldr	x0, [sp, #32]
    40083dd4:	f100001f 	cmp	x0, #0x0
    40083dd8:	54000061 	b.ne	40083de4 <strstr+0x30>  // b.any
	return (char *)s1;
    40083ddc:	f9400fe0 	ldr	x0, [sp, #24]
    40083de0:	14000018 	b	40083e40 <strstr+0x8c>
    l1 = strlen(s1);
    40083de4:	f9400fe0 	ldr	x0, [sp, #24]
    40083de8:	97ffff79 	bl	40083bcc <strlen>
    40083dec:	f90017e0 	str	x0, [sp, #40]
    while (l1 >= l2) {
    40083df0:	1400000f 	b	40083e2c <strstr+0x78>
	l1--;
    40083df4:	f94017e0 	ldr	x0, [sp, #40]
    40083df8:	d1000400 	sub	x0, x0, #0x1
    40083dfc:	f90017e0 	str	x0, [sp, #40]
	if (!memcmp(s1, s2, l2))
    40083e00:	f94013e2 	ldr	x2, [sp, #32]
    40083e04:	f9400be1 	ldr	x1, [sp, #16]
    40083e08:	f9400fe0 	ldr	x0, [sp, #24]
    40083e0c:	94000043 	bl	40083f18 <memcmp>
    40083e10:	7100001f 	cmp	w0, #0x0
    40083e14:	54000061 	b.ne	40083e20 <strstr+0x6c>  // b.any
	    return (char *)s1;
    40083e18:	f9400fe0 	ldr	x0, [sp, #24]
    40083e1c:	14000009 	b	40083e40 <strstr+0x8c>
	s1++;
    40083e20:	f9400fe0 	ldr	x0, [sp, #24]
    40083e24:	91000400 	add	x0, x0, #0x1
    40083e28:	f9000fe0 	str	x0, [sp, #24]
    while (l1 >= l2) {
    40083e2c:	f94017e1 	ldr	x1, [sp, #40]
    40083e30:	f94013e0 	ldr	x0, [sp, #32]
    40083e34:	eb00003f 	cmp	x1, x0
    40083e38:	54fffde2 	b.cs	40083df4 <strstr+0x40>  // b.hs, b.nlast
    }
    return NULL;
    40083e3c:	d2800000 	mov	x0, #0x0                   	// #0
}
    40083e40:	a8c37bfd 	ldp	x29, x30, [sp], #48
    40083e44:	d65f03c0 	ret

0000000040083e48 <memset>:

void *memset(void *s, int c, size_t n)
{
    40083e48:	d100c3ff 	sub	sp, sp, #0x30
    40083e4c:	f9000fe0 	str	x0, [sp, #24]
    40083e50:	b90017e1 	str	w1, [sp, #20]
    40083e54:	f90007e2 	str	x2, [sp, #8]
    size_t i;
    char *a = s;
    40083e58:	f9400fe0 	ldr	x0, [sp, #24]
    40083e5c:	f90013e0 	str	x0, [sp, #32]

    for (i = 0; i < n; ++i)
    40083e60:	f90017ff 	str	xzr, [sp, #40]
    40083e64:	1400000a 	b	40083e8c <memset+0x44>
        a[i] = c;
    40083e68:	f94013e1 	ldr	x1, [sp, #32]
    40083e6c:	f94017e0 	ldr	x0, [sp, #40]
    40083e70:	8b000020 	add	x0, x1, x0
    40083e74:	b94017e1 	ldr	w1, [sp, #20]
    40083e78:	12001c21 	and	w1, w1, #0xff
    40083e7c:	39000001 	strb	w1, [x0]
    for (i = 0; i < n; ++i)
    40083e80:	f94017e0 	ldr	x0, [sp, #40]
    40083e84:	91000400 	add	x0, x0, #0x1
    40083e88:	f90017e0 	str	x0, [sp, #40]
    40083e8c:	f94017e1 	ldr	x1, [sp, #40]
    40083e90:	f94007e0 	ldr	x0, [sp, #8]
    40083e94:	eb00003f 	cmp	x1, x0
    40083e98:	54fffe83 	b.cc	40083e68 <memset+0x20>  // b.lo, b.ul, b.last

    return s;
    40083e9c:	f9400fe0 	ldr	x0, [sp, #24]
}
    40083ea0:	9100c3ff 	add	sp, sp, #0x30
    40083ea4:	d65f03c0 	ret

0000000040083ea8 <memcpy>:

void *memcpy(void *dest, const void *src, size_t n)
{
    40083ea8:	d10103ff 	sub	sp, sp, #0x40
    40083eac:	f9000fe0 	str	x0, [sp, #24]
    40083eb0:	f9000be1 	str	x1, [sp, #16]
    40083eb4:	f90007e2 	str	x2, [sp, #8]
    size_t i;
    char *a = dest;
    40083eb8:	f9400fe0 	ldr	x0, [sp, #24]
    40083ebc:	f9001be0 	str	x0, [sp, #48]
    const char *b = src;
    40083ec0:	f9400be0 	ldr	x0, [sp, #16]
    40083ec4:	f90017e0 	str	x0, [sp, #40]

    for (i = 0; i < n; ++i)
    40083ec8:	f9001fff 	str	xzr, [sp, #56]
    40083ecc:	1400000c 	b	40083efc <memcpy+0x54>
        a[i] = b[i];
    40083ed0:	f94017e1 	ldr	x1, [sp, #40]
    40083ed4:	f9401fe0 	ldr	x0, [sp, #56]
    40083ed8:	8b000021 	add	x1, x1, x0
    40083edc:	f9401be2 	ldr	x2, [sp, #48]
    40083ee0:	f9401fe0 	ldr	x0, [sp, #56]
    40083ee4:	8b000040 	add	x0, x2, x0
    40083ee8:	39400021 	ldrb	w1, [x1]
    40083eec:	39000001 	strb	w1, [x0]
    for (i = 0; i < n; ++i)
    40083ef0:	f9401fe0 	ldr	x0, [sp, #56]
    40083ef4:	91000400 	add	x0, x0, #0x1
    40083ef8:	f9001fe0 	str	x0, [sp, #56]
    40083efc:	f9401fe1 	ldr	x1, [sp, #56]
    40083f00:	f94007e0 	ldr	x0, [sp, #8]
    40083f04:	eb00003f 	cmp	x1, x0
    40083f08:	54fffe43 	b.cc	40083ed0 <memcpy+0x28>  // b.lo, b.ul, b.last

    return dest;
    40083f0c:	f9400fe0 	ldr	x0, [sp, #24]
}
    40083f10:	910103ff 	add	sp, sp, #0x40
    40083f14:	d65f03c0 	ret

0000000040083f18 <memcmp>:

int memcmp(const void *s1, const void *s2, size_t n)
{
    40083f18:	d10103ff 	sub	sp, sp, #0x40
    40083f1c:	f9000fe0 	str	x0, [sp, #24]
    40083f20:	f9000be1 	str	x1, [sp, #16]
    40083f24:	f90007e2 	str	x2, [sp, #8]
    const unsigned char *a = s1, *b = s2;
    40083f28:	f9400fe0 	ldr	x0, [sp, #24]
    40083f2c:	f9001fe0 	str	x0, [sp, #56]
    40083f30:	f9400be0 	ldr	x0, [sp, #16]
    40083f34:	f9001be0 	str	x0, [sp, #48]
    int ret = 0;
    40083f38:	b9002fff 	str	wzr, [sp, #44]

    while (n--) {
    40083f3c:	14000011 	b	40083f80 <memcmp+0x68>
	ret = *a - *b;
    40083f40:	f9401fe0 	ldr	x0, [sp, #56]
    40083f44:	39400000 	ldrb	w0, [x0]
    40083f48:	2a0003e1 	mov	w1, w0
    40083f4c:	f9401be0 	ldr	x0, [sp, #48]
    40083f50:	39400000 	ldrb	w0, [x0]
    40083f54:	4b000020 	sub	w0, w1, w0
    40083f58:	b9002fe0 	str	w0, [sp, #44]
	if (ret)
    40083f5c:	b9402fe0 	ldr	w0, [sp, #44]
    40083f60:	7100001f 	cmp	w0, #0x0
    40083f64:	540001a1 	b.ne	40083f98 <memcmp+0x80>  // b.any
	    break;
	++a, ++b;
    40083f68:	f9401fe0 	ldr	x0, [sp, #56]
    40083f6c:	91000400 	add	x0, x0, #0x1
    40083f70:	f9001fe0 	str	x0, [sp, #56]
    40083f74:	f9401be0 	ldr	x0, [sp, #48]
    40083f78:	91000400 	add	x0, x0, #0x1
    40083f7c:	f9001be0 	str	x0, [sp, #48]
    while (n--) {
    40083f80:	f94007e0 	ldr	x0, [sp, #8]
    40083f84:	d1000401 	sub	x1, x0, #0x1
    40083f88:	f90007e1 	str	x1, [sp, #8]
    40083f8c:	f100001f 	cmp	x0, #0x0
    40083f90:	54fffd81 	b.ne	40083f40 <memcmp+0x28>  // b.any
    40083f94:	14000002 	b	40083f9c <memcmp+0x84>
	    break;
    40083f98:	d503201f 	nop
    }
    return ret;
    40083f9c:	b9402fe0 	ldr	w0, [sp, #44]
}
    40083fa0:	910103ff 	add	sp, sp, #0x40
    40083fa4:	d65f03c0 	ret

0000000040083fa8 <memmove>:

void *memmove(void *dest, const void *src, size_t n)
{
    40083fa8:	d100c3ff 	sub	sp, sp, #0x30
    40083fac:	f9000fe0 	str	x0, [sp, #24]
    40083fb0:	f9000be1 	str	x1, [sp, #16]
    40083fb4:	f90007e2 	str	x2, [sp, #8]
    const unsigned char *s = src;
    40083fb8:	f9400be0 	ldr	x0, [sp, #16]
    40083fbc:	f90017e0 	str	x0, [sp, #40]
    unsigned char *d = dest;
    40083fc0:	f9400fe0 	ldr	x0, [sp, #24]
    40083fc4:	f90013e0 	str	x0, [sp, #32]

    if (d <= s) {
    40083fc8:	f94013e1 	ldr	x1, [sp, #32]
    40083fcc:	f94017e0 	ldr	x0, [sp, #40]
    40083fd0:	eb00003f 	cmp	x1, x0
    40083fd4:	54000208 	b.hi	40084014 <memmove+0x6c>  // b.pmore
	while (n--)
    40083fd8:	14000009 	b	40083ffc <memmove+0x54>
	    *d++ = *s++;
    40083fdc:	f94017e1 	ldr	x1, [sp, #40]
    40083fe0:	91000420 	add	x0, x1, #0x1
    40083fe4:	f90017e0 	str	x0, [sp, #40]
    40083fe8:	f94013e0 	ldr	x0, [sp, #32]
    40083fec:	91000402 	add	x2, x0, #0x1
    40083ff0:	f90013e2 	str	x2, [sp, #32]
    40083ff4:	39400021 	ldrb	w1, [x1]
    40083ff8:	39000001 	strb	w1, [x0]
	while (n--)
    40083ffc:	f94007e0 	ldr	x0, [sp, #8]
    40084000:	d1000401 	sub	x1, x0, #0x1
    40084004:	f90007e1 	str	x1, [sp, #8]
    40084008:	f100001f 	cmp	x0, #0x0
    4008400c:	54fffe81 	b.ne	40083fdc <memmove+0x34>  // b.any
    40084010:	14000019 	b	40084074 <memmove+0xcc>
    } else {
	d += n, s += n;
    40084014:	f94013e1 	ldr	x1, [sp, #32]
    40084018:	f94007e0 	ldr	x0, [sp, #8]
    4008401c:	8b000020 	add	x0, x1, x0
    40084020:	f90013e0 	str	x0, [sp, #32]
    40084024:	f94017e1 	ldr	x1, [sp, #40]
    40084028:	f94007e0 	ldr	x0, [sp, #8]
    4008402c:	8b000020 	add	x0, x1, x0
    40084030:	f90017e0 	str	x0, [sp, #40]
	while (n--)
    40084034:	1400000b 	b	40084060 <memmove+0xb8>
	    *--d = *--s;
    40084038:	f94017e0 	ldr	x0, [sp, #40]
    4008403c:	d1000400 	sub	x0, x0, #0x1
    40084040:	f90017e0 	str	x0, [sp, #40]
    40084044:	f94013e0 	ldr	x0, [sp, #32]
    40084048:	d1000400 	sub	x0, x0, #0x1
    4008404c:	f90013e0 	str	x0, [sp, #32]
    40084050:	f94017e0 	ldr	x0, [sp, #40]
    40084054:	39400001 	ldrb	w1, [x0]
    40084058:	f94013e0 	ldr	x0, [sp, #32]
    4008405c:	39000001 	strb	w1, [x0]
	while (n--)
    40084060:	f94007e0 	ldr	x0, [sp, #8]
    40084064:	d1000401 	sub	x1, x0, #0x1
    40084068:	f90007e1 	str	x1, [sp, #8]
    4008406c:	f100001f 	cmp	x0, #0x0
    40084070:	54fffe41 	b.ne	40084038 <memmove+0x90>  // b.any
    }
    return dest;
    40084074:	f9400fe0 	ldr	x0, [sp, #24]
}
    40084078:	9100c3ff 	add	sp, sp, #0x30
    4008407c:	d65f03c0 	ret

0000000040084080 <memchr>:

void *memchr(const void *s, int c, size_t n)
{
    40084080:	d100c3ff 	sub	sp, sp, #0x30
    40084084:	f9000fe0 	str	x0, [sp, #24]
    40084088:	b90017e1 	str	w1, [sp, #20]
    4008408c:	f90007e2 	str	x2, [sp, #8]
    const unsigned char *str = s, chr = (unsigned char)c;
    40084090:	f9400fe0 	ldr	x0, [sp, #24]
    40084094:	f90017e0 	str	x0, [sp, #40]
    40084098:	b94017e0 	ldr	w0, [sp, #20]
    4008409c:	39009fe0 	strb	w0, [sp, #39]

    while (n--)
    400840a0:	1400000b 	b	400840cc <memchr+0x4c>
	if (*str++ == chr)
    400840a4:	f94017e0 	ldr	x0, [sp, #40]
    400840a8:	91000401 	add	x1, x0, #0x1
    400840ac:	f90017e1 	str	x1, [sp, #40]
    400840b0:	39400000 	ldrb	w0, [x0]
    400840b4:	39409fe1 	ldrb	w1, [sp, #39]
    400840b8:	6b00003f 	cmp	w1, w0
    400840bc:	54000081 	b.ne	400840cc <memchr+0x4c>  // b.any
	    return (void *)(str - 1);
    400840c0:	f94017e0 	ldr	x0, [sp, #40]
    400840c4:	d1000400 	sub	x0, x0, #0x1
    400840c8:	14000007 	b	400840e4 <memchr+0x64>
    while (n--)
    400840cc:	f94007e0 	ldr	x0, [sp, #8]
    400840d0:	d1000401 	sub	x1, x0, #0x1
    400840d4:	f90007e1 	str	x1, [sp, #8]
    400840d8:	f100001f 	cmp	x0, #0x0
    400840dc:	54fffe41 	b.ne	400840a4 <memchr+0x24>  // b.any
    return NULL;
    400840e0:	d2800000 	mov	x0, #0x0                   	// #0
}
    400840e4:	9100c3ff 	add	sp, sp, #0x30
    400840e8:	d65f03c0 	ret

00000000400840ec <atol>:

long atol(const char *ptr)
{
    400840ec:	d100c3ff 	sub	sp, sp, #0x30
    400840f0:	f90007e0 	str	x0, [sp, #8]
    long acc = 0;
    400840f4:	f90017ff 	str	xzr, [sp, #40]
    const char *s = ptr;
    400840f8:	f94007e0 	ldr	x0, [sp, #8]
    400840fc:	f90013e0 	str	x0, [sp, #32]
    int neg, c;

    while (*s == ' ' || *s == '\t')
    40084100:	14000004 	b	40084110 <atol+0x24>
        s++;
    40084104:	f94013e0 	ldr	x0, [sp, #32]
    40084108:	91000400 	add	x0, x0, #0x1
    4008410c:	f90013e0 	str	x0, [sp, #32]
    while (*s == ' ' || *s == '\t')
    40084110:	f94013e0 	ldr	x0, [sp, #32]
    40084114:	39400000 	ldrb	w0, [x0]
    40084118:	7100801f 	cmp	w0, #0x20
    4008411c:	54ffff40 	b.eq	40084104 <atol+0x18>  // b.none
    40084120:	f94013e0 	ldr	x0, [sp, #32]
    40084124:	39400000 	ldrb	w0, [x0]
    40084128:	7100241f 	cmp	w0, #0x9
    4008412c:	54fffec0 	b.eq	40084104 <atol+0x18>  // b.none
    if (*s == '-'){
    40084130:	f94013e0 	ldr	x0, [sp, #32]
    40084134:	39400000 	ldrb	w0, [x0]
    40084138:	7100b41f 	cmp	w0, #0x2d
    4008413c:	540000e1 	b.ne	40084158 <atol+0x6c>  // b.any
        neg = 1;
    40084140:	52800020 	mov	w0, #0x1                   	// #1
    40084144:	b9001fe0 	str	w0, [sp, #28]
        s++;
    40084148:	f94013e0 	ldr	x0, [sp, #32]
    4008414c:	91000400 	add	x0, x0, #0x1
    40084150:	f90013e0 	str	x0, [sp, #32]
    40084154:	14000022 	b	400841dc <atol+0xf0>
    } else {
        neg = 0;
    40084158:	b9001fff 	str	wzr, [sp, #28]
        if (*s == '+')
    4008415c:	f94013e0 	ldr	x0, [sp, #32]
    40084160:	39400000 	ldrb	w0, [x0]
    40084164:	7100ac1f 	cmp	w0, #0x2b
    40084168:	540003a1 	b.ne	400841dc <atol+0xf0>  // b.any
            s++;
    4008416c:	f94013e0 	ldr	x0, [sp, #32]
    40084170:	91000400 	add	x0, x0, #0x1
    40084174:	f90013e0 	str	x0, [sp, #32]
    }

    while (*s) {
    40084178:	14000019 	b	400841dc <atol+0xf0>
        if (*s < '0' || *s > '9')
    4008417c:	f94013e0 	ldr	x0, [sp, #32]
    40084180:	39400000 	ldrb	w0, [x0]
    40084184:	7100bc1f 	cmp	w0, #0x2f
    40084188:	54000329 	b.ls	400841ec <atol+0x100>  // b.plast
    4008418c:	f94013e0 	ldr	x0, [sp, #32]
    40084190:	39400000 	ldrb	w0, [x0]
    40084194:	7100e41f 	cmp	w0, #0x39
    40084198:	540002a8 	b.hi	400841ec <atol+0x100>  // b.pmore
            break;
        c = *s - '0';
    4008419c:	f94013e0 	ldr	x0, [sp, #32]
    400841a0:	39400000 	ldrb	w0, [x0]
    400841a4:	5100c000 	sub	w0, w0, #0x30
    400841a8:	b9001be0 	str	w0, [sp, #24]
        acc = acc * 10 + c;
    400841ac:	f94017e1 	ldr	x1, [sp, #40]
    400841b0:	aa0103e0 	mov	x0, x1
    400841b4:	d37ef400 	lsl	x0, x0, #2
    400841b8:	8b010000 	add	x0, x0, x1
    400841bc:	d37ff800 	lsl	x0, x0, #1
    400841c0:	aa0003e1 	mov	x1, x0
    400841c4:	b9801be0 	ldrsw	x0, [sp, #24]
    400841c8:	8b000020 	add	x0, x1, x0
    400841cc:	f90017e0 	str	x0, [sp, #40]
        s++;
    400841d0:	f94013e0 	ldr	x0, [sp, #32]
    400841d4:	91000400 	add	x0, x0, #0x1
    400841d8:	f90013e0 	str	x0, [sp, #32]
    while (*s) {
    400841dc:	f94013e0 	ldr	x0, [sp, #32]
    400841e0:	39400000 	ldrb	w0, [x0]
    400841e4:	7100001f 	cmp	w0, #0x0
    400841e8:	54fffca1 	b.ne	4008417c <atol+0x90>  // b.any
    }

    if (neg)
    400841ec:	b9401fe0 	ldr	w0, [sp, #28]
    400841f0:	7100001f 	cmp	w0, #0x0
    400841f4:	54000080 	b.eq	40084204 <atol+0x118>  // b.none
        acc = -acc;
    400841f8:	f94017e0 	ldr	x0, [sp, #40]
    400841fc:	cb0003e0 	neg	x0, x0
    40084200:	f90017e0 	str	x0, [sp, #40]

    return acc;
    40084204:	f94017e0 	ldr	x0, [sp, #40]
}
    40084208:	9100c3ff 	add	sp, sp, #0x30
    4008420c:	d65f03c0 	ret

0000000040084210 <read_cntfrq_el0>:
#ifndef __TIMER_H__
#define  __TIMER_H__

#include <aj_types.h>

static inline uint64_t read_cntfrq_el0(void) {
    40084210:	d10043ff 	sub	sp, sp, #0x10
    uint64_t val;
    asm volatile("mrs %0, cntfrq_el0" : "=r"(val));
    40084214:	d53be000 	mrs	x0, cntfrq_el0
    40084218:	f90007e0 	str	x0, [sp, #8]
    return val;
    4008421c:	f94007e0 	ldr	x0, [sp, #8]
}
    40084220:	910043ff 	add	sp, sp, #0x10
    40084224:	d65f03c0 	ret

0000000040084228 <write_cntp_tval_el0>:

static inline void write_cntfrq_el0(uint64_t val) {
    asm volatile("msr cntfrq_el0, %0" : : "r"(val));
}

static inline void write_cntp_tval_el0(uint64_t val) {
    40084228:	d10043ff 	sub	sp, sp, #0x10
    4008422c:	f90007e0 	str	x0, [sp, #8]
    asm volatile("msr cntp_tval_el0, %0" : : "r"(val));
    40084230:	f94007e0 	ldr	x0, [sp, #8]
    40084234:	d51be200 	msr	cntp_tval_el0, x0
}
    40084238:	d503201f 	nop
    4008423c:	910043ff 	add	sp, sp, #0x10
    40084240:	d65f03c0 	ret

0000000040084244 <write_cntp_ctl_el0>:

static inline void write_cntp_ctl_el0(uint64_t val) {
    40084244:	d10043ff 	sub	sp, sp, #0x10
    40084248:	f90007e0 	str	x0, [sp, #8]
    asm volatile("msr cntp_ctl_el0, %0" : : "r"(val));
    4008424c:	f94007e0 	ldr	x0, [sp, #8]
    40084250:	d51be220 	msr	cntp_ctl_el0, x0
}
    40084254:	d503201f 	nop
    40084258:	910043ff 	add	sp, sp, #0x10
    4008425c:	d65f03c0 	ret

0000000040084260 <timer_init>:
#include <gic.h>
#include <aj_types.h>

// 每个pe都要配置
void timer_init() 
{
    40084260:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    40084264:	910003fd 	mov	x29, sp

    uint64_t frq = read_cntfrq_el0();
    40084268:	97ffffea 	bl	40084210 <read_cntfrq_el0>
    4008426c:	f9000fe0 	str	x0, [sp, #24]

    // 设置定时值
    write_cntp_tval_el0(0);
    40084270:	d2800000 	mov	x0, #0x0                   	// #0
    40084274:	97ffffed 	bl	40084228 <write_cntp_tval_el0>
    // 启用定时器
    write_cntp_ctl_el0(0b1);
    40084278:	d2800020 	mov	x0, #0x1                   	// #1
    4008427c:	97fffff2 	bl	40084244 <write_cntp_ctl_el0>

    set_enable(33, true);
    40084280:	52800021 	mov	w1, #0x1                   	// #1
    40084284:	52800420 	mov	w0, #0x21                  	// #33
    40084288:	97fff927 	bl	40082724 <set_enable>
}
    4008428c:	d503201f 	nop
    40084290:	a8c27bfd 	ldp	x29, x30, [sp], #32
    40084294:	d65f03c0 	ret

0000000040084298 <handle_timer_interrupt>:


    // 重新加载定时器
    // write_cntp_tval_el0(TIMER_FREQUENCY); // 1秒中断一次

    40084298:	d503201f 	nop
    4008429c:	d65f03c0 	ret
